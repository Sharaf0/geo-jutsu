{"version":3,"sources":["drawers/PointDrawer.ts","drawers/SegmentDrawer.ts","drawers/SceneDrawer.ts","business/Point.ts","MouseEvents.ts","Drawer.tsx","App.tsx","index.tsx"],"names":["PointDrawer","points","scene","color","length","index","p","geometry","CircleGeometry","material","MeshBasicMaterial","circle","Mesh","position","setX","x","setY","y","add","SegmentDrawer","segments","segment","LineBasicMaterial","Array","push","start","toVector2","end","BufferGeometry","setFromPoints","line","Line","SceneDrawer","pointDrawer","segmentDrawer","inputPoints","inputSegments","remove","apply","children","this","draw","Color","Point","id","IDs","Vector2","MouseEvents","canvas","document","getElementById","e","button","rect","getBoundingClientRect","scaleX","width","scaleY","height","scaledPoint","clientX","left","clientY","top","Drawer","myCanvas","useRef","useState","setInputPoints","setInputSegments","Scene","sceneDrawer","useMemo","mouseEvents","useEffect","renderer","WebGLRenderer","current","setClearColor","camera","OrthographicCamera","z","animate","requestAnimationFrame","render","onMouseDown","res","Error","point","ref","style","border","App","className","ReactDOM","StrictMode"],"mappings":"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","file":"static/js/main.fc63c1b9.chunk.js","sourcesContent":["import Point from \"../business/Point\";\nimport { Scene, Mesh, CircleGeometry, MeshBasicMaterial, Color } from \"three\";\n\nexport default class PointDrawer {\n  draw(points: Array<Point>, scene: Scene, color: Color) {\n    if (points.length === 0)\n      return;\n    for (let index = 0; index < points.length; index++) {\n      const p = points[index];\n      const geometry = new CircleGeometry(2, 10);\n      const material = new MeshBasicMaterial({ color: color });\n      const circle = new Mesh(geometry, material);\n      circle.position.setX(p.x);\n      circle.position.setY(p.y);\n      scene.add(circle);\n    }\n  }\n}","import Segment from \"../business/Segment\";\nimport { Scene, LineBasicMaterial, BufferGeometry, Vector2, Line } from \"three\";\n\nexport default class SegmentDrawer {\n  draw(segments: Array<Segment>, scene: Scene) {\n    if (segments.length === 0)\n      return [];\n      \n    for (let index = 0; index < segments.length; index++) {\n      const segment = segments[index];\n      const material = new LineBasicMaterial({\n        color: 0x0000ff\n      });\n\n      const points = new Array<Vector2>();\n      points.push(segment.start.toVector2());\n      points.push(segment.end.toVector2());\n\n      const geometry = new BufferGeometry().setFromPoints(points);\n\n      const line = new Line(geometry, material);\n      scene.add(line);\n    }\n  }\n}","import PointDrawer from \"./PointDrawer\";\nimport { Scene, Color } from \"three\";\nimport SegmentDrawer from \"./SegmentDrawer\";\nimport Segment from \"../business/Segment\";\nimport Point from \"../business/Point\";\n\nexport default class SceneDrawer {\n  pointDrawer: PointDrawer = new PointDrawer();\n  segmentDrawer: SegmentDrawer = new SegmentDrawer();\n\n  draw(scene: Scene, inputPoints: Array<Point>, inputSegments: Array<Segment>) {\n        //clearScene\n    //TODO: Do that more efficiently\n    scene.remove.apply(scene, scene.children);\n    this.pointDrawer.draw(inputPoints, scene, new Color('blue'));\n    this.segmentDrawer.draw(inputSegments, scene);\n  }\n}","import { Vector2 } from \"three\";\n\nexport default class Point {\n  x: number;\n  y: number;\n  id: number;\n  static IDs: number = 0;\n  constructor(x: number, y: number) {\n    this.x = x;\n    this.y = y;\n    this.id = Point.IDs++;\n  }\n  toVector2() {\n    return new Vector2(this.x, this.y);\n  }\n}","import Point from \"./business/Point\";\nimport Segment from \"./business/Segment\";\n\nexport default class MouseEvents {\n  canvas: HTMLCanvasElement;\n  constructor() {\n    this.canvas = document.getElementById('element that does not exist') as HTMLCanvasElement;\n  }\n  onMouseDown(e: React.MouseEvent): (Point | Segment | /*Polygon |*/ null)[] {\n    if (e.button !== 0)\n      return [null, null, null];\n\n    const rect = this.canvas.getBoundingClientRect();\n    const scaleX = this.canvas.width / rect.width;\n    const scaleY = this.canvas.height / rect.height;\n\n    const scaledPoint = new Point((e.clientX - rect.left) * scaleX, (e.clientY - rect.top) * scaleY);\n\n    const transformedPoint = new Point(scaledPoint.x - this.canvas.width / 2,\n      this.canvas.height / 2 - scaledPoint.y);\n\n    return [transformedPoint, null, null];\n  }\n}","import React, { useRef, useEffect, useState, useMemo } from 'react';\nimport {\n  WebGLRenderer,\n  Scene,\n  OrthographicCamera,\n  Color,\n} from \"three\";\nimport Point from './business/Point';\nimport Segment from './business/Segment';\nimport SceneDrawer from './drawers/SceneDrawer';\nimport MouseEvents from './MouseEvents';\n\n//FIXME: We should not need that.\nfunction getTempCanvas(): HTMLCanvasElement {\n  return document.getElementById('element that does not exist') as HTMLCanvasElement;\n}\n\nfunction Drawer() {\n  const myCanvas = useRef<HTMLCanvasElement>(getTempCanvas());\n  const [inputPoints, setInputPoints] = useState<Array<Point>>([]);\n  const [inputSegments, setInputSegments] = useState<Array<Segment>>([]);\n  const [scene] = useState<Scene>(new Scene());\n  const sceneDrawer = useMemo(() => new SceneDrawer(), []);\n  const mouseEvents = useMemo(() => new MouseEvents(), []);\n\n  useEffect(() => {\n    const renderer = new WebGLRenderer({ canvas: myCanvas.current });\n    renderer.setClearColor(new Color('white'));\n    const camera = new OrthographicCamera(- myCanvas.current.width / 2, myCanvas.current.width / 2, myCanvas.current.height / 2, myCanvas.current.height / -2, 0.01, 2000);\n    camera.position.z = 50;\n    mouseEvents.canvas = myCanvas.current;\n    const animate = function () {\n      requestAnimationFrame(animate);\n      renderer.render(scene, camera);\n    };\n    animate();\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, []);\n\n  useEffect(() => {\n    sceneDrawer.draw(scene, inputPoints, inputSegments);\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [inputPoints, inputSegments]);\n\n  const onMouseDown = function (e: React.MouseEvent) {\n    const res = mouseEvents.onMouseDown(e);\n    if (res.length !== 3)\n      throw Error('onMouseDown must return 3 items, (Point | Segment | Polygon | null)')\n    const point = res[0] as Point;\n    const segment = res[1] as Segment;\n    if (point)\n      setInputPoints([...inputPoints, point]);\n    if (segment)\n      setInputSegments([...inputSegments, segment]);\n  }\n\n  return (\n    <canvas onMouseDown={onMouseDown} ref={myCanvas} width=\"500\" height=\"500\" style={{ border: \"1px solid black\" }}></canvas>\n  );\n}\n\nexport default Drawer;\n","import React from 'react';\nimport Drawer from './Drawer';\nimport 'bootstrap/dist/css/bootstrap.min.css';\n\nfunction App() {\n  return (\n    <div className=\"container\">\n      <div className=\"row\">\n        <div className=\"col-sm-3\">\n        </div>\n        <div className=\"col-sm-6\">\n          <Drawer />\n        </div>\n        <div className=\"col-sm-3\">\n          <h1>test</h1>\n        </div>\n      </div>\n    </div>\n  );\n}\n\nexport default App;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport App from './App';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n"],"sourceRoot":""}