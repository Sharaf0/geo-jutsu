{"version":3,"sources":["styles/button.module.scss","drawers/PointDrawer.ts","drawers/SegmentDrawer.ts","drawers/ColorsGenerator.ts","drawers/StepDrawer.ts","drawers/SceneDrawer.ts","business/Point.ts","MouseEvents.ts","DrawingModeContext.ts","DrawingArea.tsx","Button.tsx","ButtonsList.tsx","DrawingPalette.tsx","StatesPlayer.tsx","AlgorithmsList.tsx","algorithms/step.ts","algorithms/simpleAlgorithm.ts","algorithms/algorithmsFactory.ts","App.tsx","hooks/drawingMode.hook.ts","index.tsx"],"names":["module","exports","PointDrawer","points","scene","color","length","index","p","geometry","CircleGeometry","material","MeshBasicMaterial","circle","Mesh","position","setX","x","setY","y","add","SegmentDrawer","segments","segment","LineBasicMaterial","push","start","toVector2","end","BufferGeometry","setFromPoints","line","Line","ColorsGenerator","Math","floor","random","suggestedColorHex","getRandomColor","allColors","newColorHex","getNewRandomColorHex","Color","setHex","pointsGroupColors","segmentsGroupColors","getNewPointsGroupColor","getNewSegmentsGroupColor","getHex","Array","StepDrawer","pointDrawer","segmentDrawer","this","step","pointsGroups","segmentsGroups","pointsGroup","draw","getRandomPointsGroupColor","segmentsGroup","getRandomSegmentsGroupColor","SceneDrawer","stepDrawer","inputPoints","inputSegments","beingDrawenPoint","beingDrawenSegment","currentStep","remove","apply","children","getDefaultPointColor","getDefaultSegmentColor","Point","id","IDs","Vector2","MouseEvents","canvas","document","getElementById","mouseX","mouseY","rect","getBoundingClientRect","scaleX","width","scaleY","height","scaledPoint","left","top","drawingMode","e","button","getPoint","clientX","clientY","DEFAULT_DRAWING_MODE_VALUE","setCurrentDrawingMode","drawingModeContext","React","createContext","DrawingArea","props","myCanvas","useRef","useState","setInputPoints","setInputSegments","Scene","sceneDrawer","useMemo","mouseEvents","useContext","setBeingDrawenPoint","setBeingDrawenSegment","drawingStep","useEffect","renderer","WebGLRenderer","current","setClearColor","camera","OrthographicCamera","z","animate","requestAnimationFrame","render","onMouseDown","res","Error","point","onMouseMove","onMouseLeave","ref","style","border","Button","backgroundColor","originalColor","myClasses","classNames","classes","myButton","clicked","isClicked","clickedColor","onClick","value","className","ButtonsList","buttons","setButtons","useCallback","find","b","newButtons","map","newButton","key","DrawingPalette","btn","StatesPlayer","display","justifyContent","type","marginTop","role","AlgorithmsList","algorithm","algorithms","algo","Name","Run","Step","simpleAlgorithm","onlyStep","console","log","AlgorithmsFactory","drawingButtons","App","setDrawingMode","newDrawingMode","useDrawingMode","algorithmFactory","Provider","getAll","ReactDOM","StrictMode"],"mappings":"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","file":"static/js/main.17bf6c0e.chunk.js","sourcesContent":["// extracted by mini-css-extract-plugin\nmodule.exports = {\"clicked\":\"button_clicked__R6E18\",\"myButton\":\"button_myButton__2Rz3z\",\"wiggle\":\"button_wiggle__3rqZd\"};","import Point from \"../business/Point\";\nimport { Scene, Mesh, CircleGeometry, MeshBasicMaterial, Color } from \"three\";\n\nexport default class PointDrawer {\n  draw(points: Point[], scene: Scene, color: Color) {\n    if (points.length === 0) return;\n    for (let index = 0; index < points.length; index++) {\n      const p = points[index];\n      const geometry = new CircleGeometry(2, 10);\n      const material = new MeshBasicMaterial({ color: color });\n      const circle = new Mesh(geometry, material);\n      circle.position.setX(p.x);\n      circle.position.setY(p.y);\n      scene.add(circle);\n    }\n  }\n}\n","import Segment from \"../business/Segment\";\nimport {\n  Scene,\n  LineBasicMaterial,\n  BufferGeometry,\n  Vector2,\n  Line,\n  Color,\n} from \"three\";\n\nexport default class SegmentDrawer {\n  draw(segments: Segment[], scene: Scene, color: Color): void {\n    if (segments.length === 0) return;\n\n    for (let index = 0; index < segments.length; index++) {\n      const segment = segments[index];\n      const material = new LineBasicMaterial({ color });\n\n      const points: Vector2[] = [];\n      points.push(segment.start.toVector2());\n      points.push(segment.end.toVector2());\n\n      const geometry = new BufferGeometry().setFromPoints(points);\n\n      const line = new Line(geometry, material);\n      scene.add(line);\n    }\n  }\n}\n","import { Color } from \"three\";\n\nexport default class ColorsGenerator {\n  private static pointsGroupColors: Color[] = new Array<Color>();\n  private static segmentsGroupColors: Color[] = new Array<Color>();\n  private static allColors: { [key: number]: number } = {};\n\n  private static getRandomColor(): number {\n    return Math.floor(Math.random() * 0xffffff);\n  }\n\n  private static getNewRandomColorHex(): number {\n    let suggestedColorHex = ColorsGenerator.getRandomColor();\n    while (suggestedColorHex in ColorsGenerator.allColors) {\n      suggestedColorHex = ColorsGenerator.getRandomColor();\n    }\n\n    ColorsGenerator.allColors[suggestedColorHex] = suggestedColorHex;\n    return suggestedColorHex;\n  }\n\n  private static getNewPointsGroupColor(): Color {\n    const newColorHex = ColorsGenerator.getNewRandomColorHex();\n    const color = new Color();\n    color.setHex(newColorHex);\n    ColorsGenerator.pointsGroupColors.push(color);\n    return color;\n  }\n\n  private static getNewSegmentsGroupColor(): Color {\n    const newColorHex = ColorsGenerator.getNewRandomColorHex();\n    const color = new Color();\n    color.setHex(newColorHex);\n    ColorsGenerator.segmentsGroupColors.push(color);\n    return color;\n  }\n\n  public static getRandomPointsGroupColor(index: number): Color {\n    if (ColorsGenerator.pointsGroupColors.length >= index)\n      return ColorsGenerator.pointsGroupColors[index];\n    else {\n      return ColorsGenerator.getNewPointsGroupColor();\n    }\n  }\n\n  public static getRandomSegmentsGroupColor(index: number): Color {\n    if (ColorsGenerator.segmentsGroupColors.length >= index)\n      return ColorsGenerator.segmentsGroupColors[index];\n    else {\n      return ColorsGenerator.getNewSegmentsGroupColor();\n    }\n  }\n\n  public static getDefaultPointColor(): Color {\n    const color = new Color(\"red\");\n    ColorsGenerator.allColors[color.getHex()] = color.getHex();\n    return color;\n  }\n\n  public static getDefaultSegmentColor(): Color {\n    const color = new Color(\"blue\");\n    ColorsGenerator.allColors[color.getHex()] = color.getHex();\n    return color;\n  }\n}\n","import { Scene } from \"three\";\nimport Step from \"../algorithms/step\";\nimport PointDrawer from \"./PointDrawer\";\nimport SegmentDrawer from \"./SegmentDrawer\";\nimport ColorsGenerator from \"./ColorsGenerator\";\n\nexport default class StepDrawer {\n  pointDrawer: PointDrawer;\n  segmentDrawer: SegmentDrawer;\n  constructor() {\n    this.pointDrawer = new PointDrawer();\n    this.segmentDrawer = new SegmentDrawer();\n  }\n  draw(step: Step, scene: Scene) {\n    if (!step || !step.pointsGroups.length || !step.segmentsGroups.length)\n      return;\n\n    for (let index = 0; index < step.pointsGroups.length; index++) {\n      const pointsGroup = step.pointsGroups[index];\n      this.pointDrawer.draw(\n        pointsGroup,\n        scene,\n        ColorsGenerator.getRandomPointsGroupColor(index)\n      );\n    }\n\n    for (let index = 0; index < step.segmentsGroups.length; index++) {\n      const segmentsGroup = step.segmentsGroups[index];\n      this.segmentDrawer.draw(\n        segmentsGroup,\n        scene,\n        ColorsGenerator.getRandomSegmentsGroupColor(index)\n      );\n    }\n  }\n}\n","import PointDrawer from \"./PointDrawer\";\nimport { Scene } from \"three\";\nimport SegmentDrawer from \"./SegmentDrawer\";\nimport Segment from \"../business/Segment\";\nimport Point from \"../business/Point\";\nimport Step from \"../algorithms/step\";\nimport StepDrawer from \"./StepDrawer\";\nimport ColorsGenerator from \"./ColorsGenerator\";\n\nexport default class SceneDrawer {\n  pointDrawer: PointDrawer = new PointDrawer();\n  segmentDrawer: SegmentDrawer = new SegmentDrawer();\n  stepDrawer: StepDrawer = new StepDrawer();\n\n  draw(\n    scene: Scene,\n    inputPoints: Point[],\n    inputSegments: Segment[],\n    beingDrawenPoint: Point | null,\n    beingDrawenSegment: Segment | null,\n    currentStep: Step | null\n  ) {\n    //TODO: Do that more efficiently\n    //clearScene\n    if (beingDrawenPoint) {\n      inputPoints = [...inputPoints, beingDrawenPoint];\n    }\n    if (beingDrawenSegment) {\n      inputSegments = [...inputSegments, beingDrawenSegment];\n    }\n    scene.remove.apply(scene, scene.children);\n    this.pointDrawer.draw(\n      inputPoints,\n      scene,\n      ColorsGenerator.getDefaultPointColor()\n    );\n    this.segmentDrawer.draw(\n      inputSegments,\n      scene,\n      ColorsGenerator.getDefaultSegmentColor()\n    );\n    if (currentStep) this.stepDrawer.draw(currentStep, scene);\n  }\n}\n","import { Vector2 } from \"three\";\n\nexport default class Point {\n  x: number;\n  y: number;\n  id: number;\n  static IDs: number = 0;\n  constructor(x: number, y: number) {\n    this.x = x;\n    this.y = y;\n    this.id = Point.IDs++;\n  }\n  toVector2() {\n    return new Vector2(this.x, this.y);\n  }\n}\n","import Point from \"./business/Point\";\nimport Segment from \"./business/Segment\";\n\nexport default class MouseEvents {\n  canvas: HTMLCanvasElement;\n  constructor() {\n    this.canvas = document.getElementById(\n      \"element that does not exist\"\n    ) as HTMLCanvasElement;\n  }\n  private getPoint(mouseX: number, mouseY: number): Point {\n    const rect = this.canvas.getBoundingClientRect();\n    const scaleX = this.canvas.width / rect.width;\n    const scaleY = this.canvas.height / rect.height;\n\n    const scaledPoint = new Point(\n      (mouseX - rect.left) * scaleX,\n      (mouseY - rect.top) * scaleY\n    );\n\n    const transformedPoint = new Point(\n      scaledPoint.x - this.canvas.width / 2,\n      this.canvas.height / 2 - scaledPoint.y\n    );\n    return transformedPoint;\n  }\n  onMouseDown(\n    drawingMode: string,\n    e: React.MouseEvent\n  ): (Point | Segment | /*Polygon |*/ null)[] {\n    if (e.button !== 0) return [null, null, null];\n\n    if (drawingMode === \"Point\") {\n      const point = this.getPoint(e.clientX, e.clientY);\n      return [point, null, null];\n    }\n\n    return [null, null, null];\n  }\n  onMouseMove(\n    drawingMode: string,\n    e: React.MouseEvent\n  ): (Point | Segment | /*Polygon |*/ null)[] {\n    if (drawingMode === \"Nothing\") return [null, null, null];\n    if (drawingMode === \"Point\") {\n      const point = this.getPoint(e.clientX, e.clientY);\n      return [point, null, null];\n    }\n    return [null, null, null];\n  }\n}\n","import React from \"react\";\n\nexport interface DrawingModeContext {\n  drawingMode: string;\n  setCurrentDrawingMode: (currentDrawingMode: string) => void;\n}\n\nexport const DEFAULT_DRAWING_MODE_VALUE = {\n  drawingMode: \"Nothing\",\n  setCurrentDrawingMode: () => {},\n};\n\nexport const drawingModeContext = React.createContext<DrawingModeContext>(\n  DEFAULT_DRAWING_MODE_VALUE\n);\n","import React, { useRef, useEffect, useState, useMemo } from \"react\";\nimport { WebGLRenderer, Scene, OrthographicCamera, Color } from \"three\";\nimport Point from \"./business/Point\";\nimport Segment from \"./business/Segment\";\nimport SceneDrawer from \"./drawers/SceneDrawer\";\nimport MouseEvents from \"./MouseEvents\";\nimport { drawingModeContext } from \"./DrawingModeContext\";\nimport Step from \"./algorithms/step\";\n\n//FIXME: We should not need that.\nfunction getTempCanvas(): HTMLCanvasElement {\n  return document.getElementById(\n    \"element that does not exist\"\n  ) as HTMLCanvasElement;\n}\ninterface Props {\n  currentStep: Step | null\n}\nfunction DrawingArea(props: Props) {\n  const myCanvas = useRef<HTMLCanvasElement>(getTempCanvas());\n  const [inputPoints, setInputPoints] = useState<Point[]>([]);\n  const [inputSegments, setInputSegments] = useState<Segment[]>([]);\n  const [scene] = useState<Scene>(new Scene());\n  const sceneDrawer = useMemo(() => new SceneDrawer(), []);\n  const mouseEvents = useMemo(() => new MouseEvents(), []);\n  const { drawingMode } = React.useContext(drawingModeContext);\n  const [beingDrawenPoint, setBeingDrawenPoint] = useState<Point | null>(null);\n  const [beingDrawenSegment, setBeingDrawenSegment] = useState<Segment | null>(\n    null\n  );\n  const [drawingStep] = useState<boolean>(!!props.currentStep);\n\n  useEffect(() => {\n    const renderer = new WebGLRenderer({ canvas: myCanvas.current });\n    renderer.setClearColor(new Color(\"white\"));\n    const camera = new OrthographicCamera(\n      -myCanvas.current.width / 2,\n      myCanvas.current.width / 2,\n      myCanvas.current.height / 2,\n      myCanvas.current.height / -2,\n      0.01,\n      2000\n    );\n    camera.position.z = 50;\n    mouseEvents.canvas = myCanvas.current;\n    const animate = function () {\n      requestAnimationFrame(animate);\n      renderer.render(scene, camera);\n    };\n    animate();\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, []);\n\n  useEffect(() => {\n    sceneDrawer.draw(\n      scene,\n      inputPoints,\n      inputSegments,\n      beingDrawenPoint,\n      beingDrawenSegment,\n      props.currentStep\n    );\n  }, [inputPoints, inputSegments, beingDrawenPoint, beingDrawenSegment, sceneDrawer, scene, props.currentStep]);\n\n  const onMouseDown = function (e: React.MouseEvent) {\n    if(drawingStep)\n      return;\n    const res = mouseEvents.onMouseDown(drawingMode, e);\n    if (res.length !== 3)\n      throw Error(\"onMouseDown must return 3 items, [Point, Segment, Polygon]\");\n    const point = res[0] as Point;\n    const segment = res[1] as Segment;\n    if (point) setInputPoints([...inputPoints, point]);\n    if (segment) setInputSegments([...inputSegments, segment]);\n  };\n\n  const onMouseMove = function (e: React.MouseEvent) {\n    if(drawingStep)\n      return;\n    const res = mouseEvents.onMouseMove(drawingMode, e);\n    if (res.length !== 3)\n      throw Error(\"onMouseMove must return 3 items, [Point, Segment, Polygon]\");\n    const point = res[0] as Point;\n    const segment = res[1] as Segment;\n    if (point) setBeingDrawenPoint(point);\n    if (segment) setBeingDrawenSegment(segment);\n  };\n\n  const onMouseLeave = function () {\n    setBeingDrawenPoint(null);\n    setBeingDrawenSegment(null);\n  };\n\n  return (\n    <canvas\n      onMouseDown={onMouseDown}\n      onMouseMove={onMouseMove}\n      onMouseLeave={onMouseLeave}\n      ref={myCanvas}\n      width=\"500\"\n      height=\"500\"\n      style={{ border: \"1px solid black\" }}\n    ></canvas>\n  );\n}\n\nexport default DrawingArea;\n","import React from \"react\";\nimport classes from \"./styles/button.module.scss\";\nimport classNames from \"classnames\";\n\nexport interface ButtonProps {\n  onClick: (value: string) => void;\n  value: string;\n  originalColor: string;\n  clickedColor: string;\n  isClicked: boolean;\n}\n\nfunction Button(props: ButtonProps) {\n  const style = {\n    backgroundColor: props.originalColor,\n  };\n  const myClasses = classNames({\n    [classes.myButton]: true,\n    [classes.clicked]: props.isClicked,\n  });\n\n  if (props.isClicked) {\n    style.backgroundColor = props.clickedColor;\n  }\n  const onClick = function () {\n    if (!props.isClicked) props.onClick(props.value);\n  };\n  return (\n    <button style={style} onClick={onClick} className={myClasses}>\n      {props.value}\n    </button>\n  );\n}\n\nexport default Button;\n","import React, { useCallback, useState, useEffect } from \"react\";\nimport Button, { ButtonProps } from \"./Button\";\n\ninterface Props {\n  buttons: ButtonProps[];\n}\n\nconst ButtonsList = function (props: Props) {\n  const [buttons, setButtons] = useState<ButtonProps[]>([]);\n\n  useEffect(() => {\n    setButtons(props.buttons);\n  }, [props.buttons]);\n\n  const onClick = useCallback(\n    function (value: string): void {\n      //TODO: Change the current drawingContext\n      const button = buttons.find((b) => b.value === value);\n      if (!button) throw Error(`value ${value} must be found!`);\n\n      if (button.isClicked)\n        throw Error(\n          `this function should not be called if the button is already clicked!`\n        );\n\n      const newButtons = buttons.map((button) =>\n        button.value === value\n          ? { ...button, isClicked: true }\n          : { ...button, isClicked: false }\n      );\n      setButtons(newButtons);\n    },\n    [buttons]\n  );\n\n  return (\n    <div>\n      {buttons.map((button) => {\n        const newButton = {\n          ...button,\n          onClick: (value: string) => {\n            onClick(value);\n            button.onClick(value);\n          },\n        };\n        return <Button key={newButton.value} {...newButton}></Button>;\n      })}\n    </div>\n  );\n};\n\nexport { ButtonsList };\n","import React, { useCallback } from \"react\";\nimport { ButtonProps } from \"./Button\";\nimport { ButtonsList } from \"./ButtonsList\";\nimport { drawingModeContext } from \"./DrawingModeContext\";\n\ninterface Props {\n  buttons: Omit<ButtonProps, \"onClick\">[];\n}\n\nfunction DrawingPalette(props: Props) {\n  const { drawingMode, setCurrentDrawingMode } = React.useContext(\n    drawingModeContext\n  );\n\n  const onClick = useCallback(\n    function (value: string) {\n      setCurrentDrawingMode(value);\n    },\n    [setCurrentDrawingMode]\n  );\n\n  const buttons = props.buttons.map((btn) =>\n    btn.value === drawingMode\n      ? { ...btn, onClick, isClicked: true }\n      : { ...btn, onClick }\n  );\n\n  return (\n    <div className=\"btn-group-vertical\">\n      <ButtonsList buttons={buttons} />\n      <span>{drawingMode}</span>\n    </div>\n  );\n}\n\nexport default DrawingPalette;\n","import React from \"react\";\n\nexport const StatesPlayer = function () {\n  return (\n    <>\n      <div style={{ display: \"flex\", justifyContent: \"center\" }}>\n        <button type=\"button\" className=\"btn btn-primary\">\n          {\"<<\"}\n        </button>\n        <button type=\"button\" className=\"btn btn-primary\">\n          {\"<\"}\n        </button>\n        <button type=\"button\" className=\"btn btn-primary\">\n          {\"Start\"}\n        </button>\n        <button type=\"button\" className=\"btn btn-primary\">\n          {\">\"}\n        </button>\n        <button type=\"button\" className=\"btn btn-primary\">\n          {\">>\"}\n        </button>\n      </div>\n      <div className=\"progress\" style={{marginTop: 20}}>\n        <div\n          className=\"progress-bar progress-bar-striped progress-bar-animated\"\n          role=\"progressbar\"\n          style={{ width: \"75%\" }}\n        ></div>\n      </div>\n    </>\n  );\n};\n","import React from \"react\";\nimport { ButtonsList } from \"./ButtonsList\";\nimport IAlgorithm from \"./algorithms/IAlgorithm\";\ninterface AlgorithmsListPropTypes {\n  algorithms: IAlgorithm[];\n}\n\nconst AlgorithmsList = function (props: AlgorithmsListPropTypes) {\n  const onClick = function (value: string) {\n    const algorithm = props.algorithms.find(algo => algo.Name() === value);\n    if (!algorithm)\n      throw Error(`Algorithm ${value} must be found`);\n    algorithm.Run([], []);\n  };\n  const buttons = props.algorithms.map(algorithm => ({\n    value: algorithm.Name(),\n    //TODO: Get those from config.\n    clickedColor: \"darkblue\",\n    originalColor: \"lightblue\",\n    isClicked: false,\n    onClick: onClick,\n  }));\n  return (\n    <>\n      <h2>Algorithms</h2>\n      <ButtonsList buttons={buttons} />\n    </>\n  );\n};\n\nexport default AlgorithmsList;\n","import Point from \"../business/Point\";\nimport Segment from \"../business/Segment\";\n\nexport default class Step {\n  pointsGroups: Point[][];\n  segmentsGroups: Segment[][];\n  constructor() {\n    this.pointsGroups = new Array<Array<Point>>();\n    this.segmentsGroups = new Array<Array<Segment>>();\n  }\n  //TODO: Clone()\n}\n","import Step from \"./step\";\nimport Point from \"../business/Point\";\nimport Segment from \"../business/Segment\";\nimport IAlgorithm from \"./IAlgorithm\";\n\nexport default class simpleAlgorithm implements IAlgorithm {\n  Run(inputPoints: Point[], inputSegments: Segment[]): Step[] {\n    const onlyStep = new Step();\n    onlyStep.pointsGroups.push(inputPoints);\n    console.log(\"I am a simple algorithm\");\n    return [onlyStep];\n  }\n  Name(): string {\n    return \"Simple\";\n  }\n}\n","import IAlgorithm from \"./IAlgorithm\";\nimport simpleAlgorithm from \"./simpleAlgorithm\";\n\nexport default class AlgorithmsFactory {\n  algorithms: IAlgorithm[];\n  constructor() {\n    this.algorithms = [new simpleAlgorithm()];\n  }\n  getAll(): IAlgorithm[] {\n    return this.algorithms;\n  }\n}\n","import React from \"react\";\nimport DrawingArea from \"./DrawingArea\";\nimport DrawingPalette from \"./DrawingPalette\";\nimport \"bootstrap/dist/css/bootstrap.min.css\";\nimport { drawingModeContext } from \"./DrawingModeContext\";\nimport { StatesPlayer } from \"./StatesPlayer\";\nimport AlgorithmsList from \"./AlgorithmsList\";\nimport { useDrawingMode } from \"./hooks/drawingMode.hook\";\nimport AlgorithmsFactory from \"./algorithms/algorithmsFactory\";\n\n//TODO: Move that to config.\nconst drawingButtons = (function () {\n  const ret = [\n    {\n      isClicked: false,\n      value: \"Nothing\",\n      originalColor: \"lightgrey\",\n      clickedColor: \"grey\",\n    },\n    {\n      isClicked: false,\n      value: \"Point\",\n      originalColor: \"#fe2636\",\n      clickedColor: \"darkred\",\n    },\n    {\n      isClicked: false,\n      value: \"Line\",\n      originalColor: \"#f5dd33\",\n      clickedColor: \"#f9a905\",\n    },\n    {\n      isClicked: false,\n      value: \"Polygon\",\n      originalColor: \"#90eb35\",\n      clickedColor: \"green\",\n    },\n  ];\n  return ret;\n})();\n\nfunction App() {\n  const drawingMode = useDrawingMode();\n  const algorithmFactory = new AlgorithmsFactory();\n  //TODO:\n  //const [algoStepsIterator, setAlgoStepsIterator] = useState();\n  return (\n    <drawingModeContext.Provider value={drawingMode}>\n      <div className=\"container\">\n        <div className=\"row\">\n          <div className=\"col-sm-3\">\n            <AlgorithmsList algorithms={algorithmFactory.getAll()} />\n          </div>\n          <div className=\"col-sm-6\">\n            <DrawingArea currentStep={null} />\n            <StatesPlayer />\n          </div>\n          <div className=\"col-sm-3\">\n            <DrawingPalette buttons={drawingButtons} />\n          </div>\n        </div>\n      </div>\n    </drawingModeContext.Provider>\n  );\n}\n\nexport default App;\n","import React from \"react\";\nimport {\n  DrawingModeContext,\n  DEFAULT_DRAWING_MODE_VALUE,\n} from \"../DrawingModeContext\";\n\nexport const useDrawingMode = (): DrawingModeContext => {\n  const [drawingMode, setDrawingMode] = React.useState(\n    DEFAULT_DRAWING_MODE_VALUE.drawingMode\n  );\n\n  const setCurrentDrawingMode = React.useCallback(\n    (newDrawingMode: string): void => {\n      setDrawingMode(newDrawingMode);\n    },\n    []\n  );\n\n  return {\n    drawingMode,\n    setCurrentDrawingMode,\n  };\n};\n","import React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport App from \"./App\";\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById(\"root\")\n);\n"],"sourceRoot":""}