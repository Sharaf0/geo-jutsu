{"version":3,"sources":["styles/button.module.scss","drawers/PointDrawer.ts","drawers/SegmentDrawer.ts","drawers/ColorsGenerator.ts","drawers/StepDrawer.ts","drawers/SceneDrawer.ts","dataStructures/Point.ts","MouseEvents.ts","contexts/DrawingModeContext.ts","contexts/AlgorithmStepsContext.ts","contexts/InputDrawingsContext.ts","components/DrawingArea.tsx","components/Button.tsx","components/ButtonsList.tsx","components/DrawingPalette.tsx","components/StatesPlayer.tsx","components/AlgorithmsList.tsx","hooks/drawingMode.hook.ts","algorithms/step.ts","hooks/algorithmSteps.hook.ts","algorithms/simpleAlgorithm.ts","algorithms/algorithmsFactory.ts","hooks/inputDrawings.hook.ts","components/App.tsx","index.tsx"],"names":["module","exports","PointDrawer","points","scene","color","length","index","p","geometry","CircleGeometry","material","MeshBasicMaterial","circle","Mesh","position","setX","x","setY","y","add","SegmentDrawer","segments","segment","LineBasicMaterial","push","start","toVector2","end","BufferGeometry","setFromPoints","line","Line","ColorsGenerator","Math","floor","random","suggestedColorHex","getRandomColor","allColors","newColorHex","getNewRandomColorHex","Color","setHex","pointsGroupColors","segmentsGroupColors","getNewPointsGroupColor","getNewSegmentsGroupColor","getHex","Array","StepDrawer","pointDrawer","segmentDrawer","this","step","pointsGroups","segmentsGroups","pointsGroup","draw","getRandomPointsGroupColor","segmentsGroup","getRandomSegmentsGroupColor","SceneDrawer","stepDrawer","inputPoints","inputSegments","beingDrawenPoint","beingDrawenSegment","currentStep","remove","apply","children","getDefaultPointColor","getDefaultSegmentColor","Point","id","IDs","Vector2","MouseEvents","canvas","document","getElementById","mouseX","mouseY","rect","getBoundingClientRect","scaleX","width","scaleY","height","scaledPoint","left","top","drawingMode","e","button","getPoint","clientX","clientY","DEFAULT_DRAWING_MODE_VALUE","setCurrentDrawingMode","drawingModeContext","createContext","algorithmStepsContext","React","currentStepNumber","stepsCount","next","prev","run","algorithm","DEFAULT_INPUT_DRAWINGS_CONTEXT_VALUE","addPoint","point","addSegment","inputDrawingsContext","DrawingArea","myCanvas","useRef","useState","Scene","sceneDrawer","useMemo","mouseEvents","useContext","setBeingDrawenPoint","setBeingDrawenSegment","isDrawingStep","setIsDrawingStep","useEffect","renderer","WebGLRenderer","current","setClearColor","camera","OrthographicCamera","z","animate","requestAnimationFrame","render","onMouseDown","res","Error","onMouseMove","onMouseLeave","ref","style","border","Button","props","backgroundColor","originalColor","myClasses","classNames","classes","myButton","clicked","isClicked","clickedColor","onClick","value","className","ButtonsList","buttons","setButtons","useCallback","find","b","newButtons","map","newButton","key","DrawingPalette","btn","StatesPlayer","display","justifyContent","type","disabled","marginTop","role","AlgorithmsList","algorithms","algo","Name","useDrawingMode","setDrawingMode","newDrawingMode","Step","useAlgorithmSteps","currentIndex","setCurrentIndex","setCurrentStep","allSteps","setAllSteps","firstStep","algorithmSteps","Run","steps","simpleAlgorithm","AlgorithmsFactory","useInputDrawings","setInputPoints","setInputSegments","drawingButtons","App","algorithmFactory","Provider","getAll","ReactDOM","StrictMode"],"mappings":"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","file":"static/js/main.2e4620f6.chunk.js","sourcesContent":["// extracted by mini-css-extract-plugin\nmodule.exports = {\"clicked\":\"button_clicked__R6E18\",\"myButton\":\"button_myButton__2Rz3z\",\"wiggle\":\"button_wiggle__3rqZd\"};","import Point from \"../dataStructures/Point\";\nimport { Scene, Mesh, CircleGeometry, MeshBasicMaterial, Color } from \"three\";\n\nexport default class PointDrawer {\n  draw(points: Point[], scene: Scene, color: Color) {\n    if (points.length === 0) return;\n    for (let index = 0; index < points.length; index++) {\n      const p = points[index];\n      const geometry = new CircleGeometry(2, 10);\n      const material = new MeshBasicMaterial({ color: color });\n      const circle = new Mesh(geometry, material);\n      circle.position.setX(p.x);\n      circle.position.setY(p.y);\n      scene.add(circle);\n    }\n  }\n}\n","import Segment from \"../dataStructures/Segment\";\nimport {\n  Scene,\n  LineBasicMaterial,\n  BufferGeometry,\n  Vector2,\n  Line,\n  Color,\n} from \"three\";\n\nexport default class SegmentDrawer {\n  draw(segments: Segment[], scene: Scene, color: Color): void {\n    if (segments.length === 0) return;\n\n    for (let index = 0; index < segments.length; index++) {\n      const segment = segments[index];\n      const material = new LineBasicMaterial({ color });\n\n      const points: Vector2[] = [];\n      points.push(segment.start.toVector2());\n      points.push(segment.end.toVector2());\n\n      const geometry = new BufferGeometry().setFromPoints(points);\n\n      const line = new Line(geometry, material);\n      scene.add(line);\n    }\n  }\n}\n","import { Color } from \"three\";\n\nexport default class ColorsGenerator {\n  private static pointsGroupColors: Color[] = new Array<Color>();\n  private static segmentsGroupColors: Color[] = new Array<Color>();\n  private static allColors: { [key: number]: number } = {};\n\n  private static getRandomColor(): number {\n    return Math.floor(Math.random() * 0xffffff);\n  }\n\n  private static getNewRandomColorHex(): number {\n    let suggestedColorHex = ColorsGenerator.getRandomColor();\n    while (suggestedColorHex in ColorsGenerator.allColors) {\n      suggestedColorHex = ColorsGenerator.getRandomColor();\n    }\n\n    ColorsGenerator.allColors[suggestedColorHex] = suggestedColorHex;\n    return suggestedColorHex;\n  }\n\n  private static getNewPointsGroupColor(): Color {\n    const newColorHex = ColorsGenerator.getNewRandomColorHex();\n    const color = new Color();\n    color.setHex(newColorHex);\n    ColorsGenerator.pointsGroupColors.push(color);\n    return color;\n  }\n\n  private static getNewSegmentsGroupColor(): Color {\n    const newColorHex = ColorsGenerator.getNewRandomColorHex();\n    const color = new Color();\n    color.setHex(newColorHex);\n    ColorsGenerator.segmentsGroupColors.push(color);\n    return color;\n  }\n\n  public static getRandomPointsGroupColor(index: number): Color {\n    if (ColorsGenerator.pointsGroupColors.length > index)\n      return ColorsGenerator.pointsGroupColors[index];\n    else {\n      return ColorsGenerator.getNewPointsGroupColor();\n    }\n  }\n\n  public static getRandomSegmentsGroupColor(index: number): Color {\n    if (ColorsGenerator.segmentsGroupColors.length > index)\n      return ColorsGenerator.segmentsGroupColors[index];\n    else {\n      return ColorsGenerator.getNewSegmentsGroupColor();\n    }\n  }\n\n  public static getDefaultPointColor(): Color {\n    const color = new Color(\"red\");\n    ColorsGenerator.allColors[color.getHex()] = color.getHex();\n    return color;\n  }\n\n  public static getDefaultSegmentColor(): Color {\n    const color = new Color(\"blue\");\n    ColorsGenerator.allColors[color.getHex()] = color.getHex();\n    return color;\n  }\n}\n","import { Scene } from \"three\";\nimport Step from \"../algorithms/step\";\nimport PointDrawer from \"./PointDrawer\";\nimport SegmentDrawer from \"./SegmentDrawer\";\nimport ColorsGenerator from \"./ColorsGenerator\";\n\nexport default class StepDrawer {\n  pointDrawer: PointDrawer;\n  segmentDrawer: SegmentDrawer;\n  constructor() {\n    this.pointDrawer = new PointDrawer();\n    this.segmentDrawer = new SegmentDrawer();\n  }\n  draw(step: Step, scene: Scene) {\n    if (!step || (!step.pointsGroups.length && !step.segmentsGroups.length))\n      return;\n\n    for (let index = 0; index < step.pointsGroups.length; index++) {\n      const pointsGroup = step.pointsGroups[index];\n      this.pointDrawer.draw(\n        pointsGroup,\n        scene,\n        ColorsGenerator.getRandomPointsGroupColor(index)\n      );\n    }\n\n    for (let index = 0; index < step.segmentsGroups.length; index++) {\n      const segmentsGroup = step.segmentsGroups[index];\n      this.segmentDrawer.draw(\n        segmentsGroup,\n        scene,\n        ColorsGenerator.getRandomSegmentsGroupColor(index)\n      );\n    }\n  }\n}\n","import PointDrawer from \"./PointDrawer\";\nimport { Scene } from \"three\";\nimport SegmentDrawer from \"./SegmentDrawer\";\nimport Segment from \"../dataStructures/Segment\";\nimport Point from \"../dataStructures/Point\";\nimport Step from \"../algorithms/step\";\nimport StepDrawer from \"./StepDrawer\";\nimport ColorsGenerator from \"./ColorsGenerator\";\n\nexport default class SceneDrawer {\n  pointDrawer: PointDrawer = new PointDrawer();\n  segmentDrawer: SegmentDrawer = new SegmentDrawer();\n  stepDrawer: StepDrawer = new StepDrawer();\n\n  draw(\n    scene: Scene,\n    inputPoints: Point[],\n    inputSegments: Segment[],\n    beingDrawenPoint: Point | null,\n    beingDrawenSegment: Segment | null,\n    currentStep: Step | null\n  ) {\n    //TODO: Do that more efficiently\n    //clearScene\n    scene.remove.apply(scene, scene.children);\n\n    if (currentStep) {\n      this.stepDrawer.draw(currentStep, scene);\n    } else {\n      if (beingDrawenPoint) {\n        inputPoints = [...inputPoints, beingDrawenPoint];\n      }\n      if (beingDrawenSegment) {\n        inputSegments = [...inputSegments, beingDrawenSegment];\n      }\n      this.pointDrawer.draw(\n        inputPoints,\n        scene,\n        ColorsGenerator.getDefaultPointColor()\n      );\n      this.segmentDrawer.draw(\n        inputSegments,\n        scene,\n        ColorsGenerator.getDefaultSegmentColor()\n      );\n    }\n  }\n}\n","import { Vector2 } from \"three\";\n\nexport default class Point {\n  x: number;\n  y: number;\n  id: number;\n  static IDs: number = 0;\n  constructor(x: number, y: number) {\n    this.x = x;\n    this.y = y;\n    this.id = Point.IDs++;\n  }\n  toVector2() {\n    return new Vector2(this.x, this.y);\n  }\n}\n","import Point from \"./dataStructures/Point\";\nimport Segment from \"./dataStructures/Segment\";\n\nexport default class MouseEvents {\n  canvas: HTMLCanvasElement;\n  constructor() {\n    this.canvas = document.getElementById(\n      \"element that does not exist\"\n    ) as HTMLCanvasElement;\n  }\n  private getPoint(mouseX: number, mouseY: number): Point {\n    const rect = this.canvas.getBoundingClientRect();\n    const scaleX = this.canvas.width / rect.width;\n    const scaleY = this.canvas.height / rect.height;\n\n    const scaledPoint = new Point(\n      (mouseX - rect.left) * scaleX,\n      (mouseY - rect.top) * scaleY\n    );\n\n    const transformedPoint = new Point(\n      scaledPoint.x - this.canvas.width / 2,\n      this.canvas.height / 2 - scaledPoint.y\n    );\n    return transformedPoint;\n  }\n  onMouseDown(\n    drawingMode: string,\n    e: React.MouseEvent\n  ): (Point | Segment | /*Polygon |*/ null)[] {\n    if (!this.canvas || e.button !== 0) return [null, null, null];\n\n    if (drawingMode === \"Point\") {\n      const point = this.getPoint(e.clientX, e.clientY);\n      return [point, null, null];\n    }\n\n    return [null, null, null];\n  }\n  onMouseMove(\n    drawingMode: string,\n    e: React.MouseEvent\n  ): (Point | Segment | /*Polygon |*/ null)[] {\n    if (!this.canvas) return [null, null, null];\n    if (drawingMode === \"Nothing\") return [null, null, null];\n    if (drawingMode === \"Point\") {\n      const point = this.getPoint(e.clientX, e.clientY);\n      return [point, null, null];\n    }\n    return [null, null, null];\n  }\n}\n","import { createContext } from \"react\";\n\nexport interface DrawingModeContext {\n  drawingMode: string;\n  setCurrentDrawingMode: (currentDrawingMode: string) => void;\n}\n\nexport const DEFAULT_DRAWING_MODE_VALUE = {\n  drawingMode: \"Point\",\n  setCurrentDrawingMode: () => {},\n};\n\nexport const drawingModeContext = createContext<DrawingModeContext>(\n  DEFAULT_DRAWING_MODE_VALUE\n);\n","import React from \"react\";\nimport Step from \"../algorithms/step\";\nimport IAlgorithm from \"../algorithms/IAlgorithm\";\nimport Point from \"../dataStructures/Point\";\nimport Segment from \"../dataStructures/Segment\";\n\nexport interface AlgorithmStepsContext {\n  currentStep: Step | null;\n  currentStepNumber: number;\n  stepsCount: number;\n  next: () => void;\n  prev: () => void;\n  run: (\n    algorithm: IAlgorithm,\n    inputPoints: Point[],\n    inputSegments: Segment[]\n  ) => void;\n}\n\nexport const DEFAULT_ALGORITHM_STEPS_CONTEXT_VALUE: AlgorithmStepsContext = {\n  currentStep: null,\n  currentStepNumber: -1,\n  stepsCount: 0,\n  next: () => {},\n  prev: () => {},\n  run: (\n    algorithm: IAlgorithm,\n    inputPoints: Point[],\n    inputSegments: Segment[]\n  ) => {},\n};\n\nexport const algorithmStepsContext = React.createContext<AlgorithmStepsContext>(\n  DEFAULT_ALGORITHM_STEPS_CONTEXT_VALUE\n);\n","import { createContext } from \"react\";\nimport Point from \"../dataStructures/Point\";\nimport Segment from \"../dataStructures/Segment\";\n\nexport interface InputDrawingsContext {\n  inputPoints: Point[];\n  inputSegments: Segment[];\n  addPoint: (point: Point) => void;\n  addSegment: (segment: Segment) => void;\n}\n\nexport const DEFAULT_INPUT_DRAWINGS_CONTEXT_VALUE: InputDrawingsContext = {\n  inputPoints: [],\n  inputSegments: [],\n  addPoint: (point: Point) => {},\n  addSegment: (segment: Segment) => {},\n};\n\nexport const inputDrawingsContext = createContext<InputDrawingsContext>(\n  DEFAULT_INPUT_DRAWINGS_CONTEXT_VALUE\n);\n","import React, { useRef, useEffect, useState, useMemo, useContext } from \"react\";\nimport { WebGLRenderer, Scene, OrthographicCamera, Color } from \"three\";\nimport Point from \"../dataStructures/Point\";\nimport Segment from \"../dataStructures/Segment\";\nimport SceneDrawer from \"../drawers/SceneDrawer\";\nimport MouseEvents from \"../MouseEvents\";\nimport { drawingModeContext } from \"../contexts/DrawingModeContext\";\nimport { algorithmStepsContext } from \"../contexts/AlgorithmStepsContext\";\nimport { inputDrawingsContext } from \"../contexts/InputDrawingsContext\";\n\n//FIXME: We should not need that.\nfunction getTempCanvas(): HTMLCanvasElement {\n  return document.getElementById(\n    \"element that does not exist\"\n  ) as HTMLCanvasElement;\n}\nfunction DrawingArea() {\n  const myCanvas = useRef<HTMLCanvasElement>(getTempCanvas());\n  const [scene] = useState<Scene>(new Scene());\n  const sceneDrawer = useMemo(() => new SceneDrawer(), []);\n  const mouseEvents = useMemo(() => new MouseEvents(), []);\n  const { drawingMode } = useContext(drawingModeContext);\n  const { currentStep } = useContext(algorithmStepsContext);\n  const { addPoint, addSegment, inputPoints, inputSegments } = useContext(\n    inputDrawingsContext\n  );\n  const [beingDrawenPoint, setBeingDrawenPoint] = useState<Point | null>(null);\n  const [beingDrawenSegment, setBeingDrawenSegment] = useState<Segment | null>(\n    null\n  );\n  const [isDrawingStep, setIsDrawingStep] = useState<boolean>(false);\n  useEffect(() => {\n    setIsDrawingStep(currentStep !== null);\n  }, [currentStep]);\n  useEffect(() => {\n    const renderer = new WebGLRenderer({ canvas: myCanvas.current });\n    renderer.setClearColor(new Color(\"white\"));\n    const camera = new OrthographicCamera(\n      -myCanvas.current.width / 2,\n      myCanvas.current.width / 2,\n      myCanvas.current.height / 2,\n      myCanvas.current.height / -2,\n      0.01,\n      2000\n    );\n    camera.position.z = 50;\n    mouseEvents.canvas = myCanvas.current;\n    const animate = function () {\n      requestAnimationFrame(animate);\n      renderer.render(scene, camera);\n    };\n    animate();\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, []);\n\n  useEffect(() => {\n    sceneDrawer.draw(\n      scene,\n      inputPoints,\n      inputSegments,\n      beingDrawenPoint,\n      beingDrawenSegment,\n      currentStep\n    );\n  }, [\n    inputPoints,\n    inputSegments,\n    beingDrawenPoint,\n    beingDrawenSegment,\n    sceneDrawer,\n    scene,\n    currentStep,\n  ]);\n\n  const onMouseDown = function (e: React.MouseEvent) {\n    if (isDrawingStep) return;\n    const res = mouseEvents.onMouseDown(drawingMode, e);\n    if (res.length !== 3)\n      throw Error(\"onMouseDown must return 3 items, [Point, Segment, Polygon]\");\n    const point = res[0] as Point;\n    const segment = res[1] as Segment;\n    if (point) addPoint(point);\n    if (segment) addSegment(segment);\n  };\n\n  const onMouseMove = function (e: React.MouseEvent) {\n    if (isDrawingStep) return;\n    const res = mouseEvents.onMouseMove(drawingMode, e);\n    if (res.length !== 3)\n      throw Error(\"onMouseMove must return 3 items, [Point, Segment, Polygon]\");\n    const point = res[0] as Point;\n    const segment = res[1] as Segment;\n    if (point) setBeingDrawenPoint(point);\n    if (segment) setBeingDrawenSegment(segment);\n  };\n\n  const onMouseLeave = function () {\n    setBeingDrawenPoint(null);\n    setBeingDrawenSegment(null);\n  };\n  return (\n    <>\n      <canvas\n        onMouseDown={onMouseDown}\n        onMouseMove={onMouseMove}\n        onMouseLeave={onMouseLeave}\n        ref={myCanvas}\n        width=\"500\"\n        height=\"500\"\n        style={{ border: \"1px solid black\" }}\n      ></canvas>\n    </>\n  );\n}\n\nexport default DrawingArea;\n","import React from \"react\";\nimport classes from \"../styles/button.module.scss\";\nimport classNames from \"classnames\";\n\nexport interface ButtonProps {\n  onClick: (value: string) => void;\n  value: string;\n  originalColor: string;\n  clickedColor: string;\n  isClicked: boolean;\n}\n\nfunction Button(props: ButtonProps) {\n  const style = {\n    backgroundColor: props.originalColor,\n  };\n  const myClasses = classNames({\n    [classes.myButton]: true,\n    [classes.clicked]: props.isClicked,\n  });\n\n  if (props.isClicked) {\n    style.backgroundColor = props.clickedColor;\n  }\n  const onClick = function () {\n    if (!props.isClicked) props.onClick(props.value);\n  };\n  return (\n    <button style={style} onClick={onClick} className={myClasses}>\n      {props.value}\n    </button>\n  );\n}\n\nexport default Button;\n","import React, { useCallback, useState, useEffect } from \"react\";\nimport Button, { ButtonProps } from \"./Button\";\n\ninterface Props {\n  buttons: ButtonProps[];\n}\n\nconst ButtonsList = function (props: Props) {\n  const [buttons, setButtons] = useState<ButtonProps[]>([]);\n\n  useEffect(() => {\n    setButtons(props.buttons);\n  }, [props.buttons]);\n\n  const onClick = useCallback(\n    function (value: string): void {\n      //TODO: Change the current drawingContext\n      const button = buttons.find((b) => b.value === value);\n      if (!button) throw Error(`value ${value} must be found!`);\n\n      if (button.isClicked)\n        throw Error(\n          `this function should not be called if the button is already clicked!`\n        );\n\n      const newButtons = buttons.map((button) =>\n        button.value === value\n          ? { ...button, isClicked: true }\n          : { ...button, isClicked: false }\n      );\n      setButtons(newButtons);\n    },\n    [buttons]\n  );\n\n  return (\n    <div>\n      {buttons.map((button) => {\n        const newButton = {\n          ...button,\n          onClick: (value: string) => {\n            onClick(value);\n            button.onClick(value);\n          },\n        };\n        return <Button key={newButton.value} {...newButton}></Button>;\n      })}\n    </div>\n  );\n};\n\nexport { ButtonsList };\n","import React, { useCallback } from \"react\";\nimport { ButtonProps } from \"./Button\";\nimport { ButtonsList } from \"./ButtonsList\";\nimport { drawingModeContext } from \"../contexts/DrawingModeContext\";\n\ninterface Props {\n  buttons: Omit<ButtonProps, \"onClick\">[];\n}\n\nfunction DrawingPalette(props: Props) {\n  const { drawingMode, setCurrentDrawingMode } = React.useContext(\n    drawingModeContext\n  );\n\n  const onClick = useCallback(\n    function (value: string) {\n      setCurrentDrawingMode(value);\n    },\n    [setCurrentDrawingMode]\n  );\n\n  const buttons = props.buttons.map((btn) =>\n    btn.value === drawingMode\n      ? { ...btn, onClick, isClicked: true }\n      : { ...btn, onClick }\n  );\n\n  return (\n    <div className=\"btn-group-vertical\">\n      <ButtonsList buttons={buttons} />\n      <span>{drawingMode}</span>\n    </div>\n  );\n}\n\nexport default DrawingPalette;\n","import React, { useContext } from \"react\";\nimport { algorithmStepsContext } from \"../contexts/AlgorithmStepsContext\";\n\nexport const StatesPlayer = function () {\n  const { stepsCount, currentStepNumber, next, prev } = useContext(\n    algorithmStepsContext\n  );\n  if (stepsCount === 0) return <></>;\n  return (\n    <>\n      <br></br>\n      <span>\n        {currentStepNumber} / {stepsCount - 1}\n      </span>\n      <div style={{ display: \"flex\", justifyContent: \"center\" }}>\n        {/* <button type=\"button\" className=\"btn btn-primary\">\n          {\"<<\"}\n        </button> */}\n        <button\n          type=\"button\"\n          className=\"btn btn-primary\"\n          onClick={prev}\n          disabled={currentStepNumber === 0}\n        >\n          {\"<\"}\n        </button>\n        <button type=\"button\" className=\"btn btn-primary\">\n          {\"Start\"}\n        </button>\n        <button\n          type=\"button\"\n          className=\"btn btn-primary\"\n          onClick={next}\n          disabled={currentStepNumber === stepsCount - 1}\n        >\n          {\">\"}\n        </button>\n        {/* <button type=\"button\" className=\"btn btn-primary\">\n          {\">>\"}\n        </button> */}\n      </div>\n      <div className=\"progress\" style={{ marginTop: 20 }}>\n        <div\n          className=\"progress-bar progress-bar-striped progress-bar-animated\"\n          role=\"progressbar\"\n          style={{\n            width: `${(100 * currentStepNumber) / (stepsCount - 1)}%`,\n          }}\n        ></div>\n      </div>\n    </>\n  );\n};\n","import React, { useContext } from \"react\";\nimport { ButtonsList } from \"./ButtonsList\";\nimport IAlgorithm from \"../algorithms/IAlgorithm\";\nimport { algorithmStepsContext } from \"../contexts/AlgorithmStepsContext\";\nimport { inputDrawingsContext } from \"../contexts/InputDrawingsContext\";\ninterface AlgorithmsListPropTypes {\n  algorithms: IAlgorithm[];\n}\n\nconst AlgorithmsList = function (props: AlgorithmsListPropTypes) {\n  const { run } = useContext(algorithmStepsContext);\n  const { inputPoints, inputSegments } = useContext(inputDrawingsContext);\n  const onClick = function (value: string) {\n    const algorithm = props.algorithms.find((algo) => algo.Name() === value);\n    if (!algorithm) throw Error(`Algorithm ${value} must be found`);\n    run(algorithm, inputPoints, inputSegments);\n  };\n  const buttons = props.algorithms.map((algorithm) => ({\n    value: algorithm.Name(),\n    //TODO: Get those from config.\n    clickedColor: \"darkblue\",\n    originalColor: \"lightblue\",\n    isClicked: false,\n    onClick: onClick,\n  }));\n  return (\n    <>\n      <h2>Algorithms</h2>\n      <ButtonsList buttons={buttons} />\n    </>\n  );\n};\n\nexport default AlgorithmsList;\n","import { useCallback, useState } from \"react\";\nimport {\n  DrawingModeContext,\n  DEFAULT_DRAWING_MODE_VALUE,\n} from \"../contexts/DrawingModeContext\";\n\nexport const useDrawingMode = (): DrawingModeContext => {\n  const [drawingMode, setDrawingMode] = useState(\n    DEFAULT_DRAWING_MODE_VALUE.drawingMode\n  );\n\n  const setCurrentDrawingMode = useCallback((newDrawingMode: string): void => {\n    setDrawingMode(newDrawingMode);\n  }, []);\n\n  return {\n    drawingMode,\n    setCurrentDrawingMode,\n  };\n};\n","import Point from \"../dataStructures/Point\";\nimport Segment from \"../dataStructures/Segment\";\n\nexport default class Step {\n  pointsGroups: Point[][];\n  segmentsGroups: Segment[][];\n  constructor() {\n    this.pointsGroups = new Array<Array<Point>>();\n    this.segmentsGroups = new Array<Array<Segment>>();\n  }\n  //TODO: Clone()\n}\n","import { useState } from \"react\";\nimport { AlgorithmStepsContext } from \"../contexts/AlgorithmStepsContext\";\nimport Step from \"../algorithms/step\";\nimport IAlgorithm from \"../algorithms/IAlgorithm\";\nimport Point from \"../dataStructures/Point\";\nimport Segment from \"../dataStructures/Segment\";\n\nexport const useAlgorithmSteps = (): AlgorithmStepsContext => {\n  const [currentIndex, setCurrentIndex] = useState(-1);\n  const [currentStep, setCurrentStep] = useState<Step | null>(null);\n  const [allSteps, setAllSteps] = useState<Step[]>([]);\n\n  const next = function () {\n    if (currentIndex === allSteps.length - 1) return;\n    setCurrentStep(allSteps[currentIndex + 1]);\n    setCurrentIndex(currentIndex + 1);\n  };\n  const prev = function () {\n    if (currentIndex === 0) return;\n    setCurrentStep(allSteps[currentIndex - 1]);\n    setCurrentIndex(currentIndex - 1);\n  };\n  const run = function (\n    algorithm: IAlgorithm,\n    inputPoints: Point[],\n    inputSegments: Segment[]\n  ) {\n    const firstStep = new Step();\n    firstStep.pointsGroups = [inputPoints];\n    firstStep.segmentsGroups = [inputSegments];\n    const algorithmSteps = algorithm.Run(inputPoints, inputSegments);\n    const steps = [firstStep, ...algorithmSteps];\n    setAllSteps(steps);\n    setCurrentStep(steps[0]);\n    setCurrentIndex(0);\n  };\n\n  return {\n    currentStep,\n    currentStepNumber: currentIndex,\n    stepsCount: allSteps.length,\n    next,\n    prev,\n    run,\n  };\n};\n","import Step from \"./step\";\nimport Point from \"../dataStructures/Point\";\nimport Segment from \"../dataStructures/Segment\";\nimport IAlgorithm from \"./IAlgorithm\";\n\nexport default class simpleAlgorithm implements IAlgorithm {\n  Run(inputPoints: Point[], inputSegments: Segment[]): Step[] {\n    const steps = inputPoints.map((point) => {\n      const step = new Step();\n      step.pointsGroups.push([point]);\n      return step;\n    });\n    return steps;\n  }\n  Name(): string {\n    return \"Simple\";\n  }\n}\n","import IAlgorithm from \"./IAlgorithm\";\nimport simpleAlgorithm from \"./simpleAlgorithm\";\n\nexport default class AlgorithmsFactory {\n  algorithms: IAlgorithm[];\n  constructor() {\n    this.algorithms = [new simpleAlgorithm()];\n  }\n  getAll(): IAlgorithm[] {\n    return this.algorithms;\n  }\n}\n","import {\n  DEFAULT_INPUT_DRAWINGS_CONTEXT_VALUE,\n  InputDrawingsContext,\n} from \"../contexts/InputDrawingsContext\";\nimport { useState, useCallback } from \"react\";\nimport Point from \"../dataStructures/Point\";\nimport Segment from \"../dataStructures/Segment\";\n\nexport const useInputDrawings = (): InputDrawingsContext => {\n  const [inputPoints, setInputPoints] = useState(\n    DEFAULT_INPUT_DRAWINGS_CONTEXT_VALUE.inputPoints\n  );\n\n  const [inputSegments, setInputSegments] = useState(\n    DEFAULT_INPUT_DRAWINGS_CONTEXT_VALUE.inputSegments\n  );\n\n  const addPoint = useCallback(\n    (point: Point): void => {\n      setInputPoints([...inputPoints, point]);\n    },\n    [inputPoints]\n  );\n\n  const addSegment = useCallback(\n    (segment: Segment): void => {\n      setInputSegments([...inputSegments, segment]);\n    },\n    [inputSegments]\n  );\n\n  // const clearAll = useCallback(() => {\n  //   setInputPoints(DEFAULT_INPUT_DRAWINGS_CONTEXT_VALUE.inputPoints);\n  //   setInputSegments(DEFAULT_INPUT_DRAWINGS_CONTEXT_VALUE.inputSegments);\n  // }, []);\n\n  return {\n    addPoint,\n    addSegment,\n    inputPoints,\n    inputSegments,\n  };\n};\n","import React from \"react\";\nimport DrawingArea from \"./DrawingArea\";\nimport DrawingPalette from \"./DrawingPalette\";\nimport \"bootstrap/dist/css/bootstrap.min.css\";\nimport { drawingModeContext } from \"../contexts/DrawingModeContext\";\nimport { algorithmStepsContext } from \"../contexts/AlgorithmStepsContext\";\nimport { inputDrawingsContext } from \"../contexts/InputDrawingsContext\";\nimport { StatesPlayer } from \"./StatesPlayer\";\nimport AlgorithmsList from \"./AlgorithmsList\";\nimport { useDrawingMode } from \"../hooks/drawingMode.hook\";\nimport { useAlgorithmSteps } from \"../hooks/algorithmSteps.hook\";\nimport AlgorithmsFactory from \"../algorithms/algorithmsFactory\";\nimport { useInputDrawings } from \"../hooks/inputDrawings.hook\";\n\n//TODO: Move that to config.\nconst drawingButtons = (function () {\n  const ret = [\n    {\n      isClicked: false,\n      value: \"Nothing\",\n      originalColor: \"lightgrey\",\n      clickedColor: \"grey\",\n    },\n    {\n      isClicked: false,\n      value: \"Point\",\n      originalColor: \"#fe2636\",\n      clickedColor: \"darkred\",\n    },\n    {\n      isClicked: false,\n      value: \"Line\",\n      originalColor: \"#f5dd33\",\n      clickedColor: \"#f9a905\",\n    },\n    {\n      isClicked: false,\n      value: \"Polygon\",\n      originalColor: \"#90eb35\",\n      clickedColor: \"green\",\n    },\n  ];\n  return ret;\n})();\n\nfunction App() {\n  const algorithmFactory = new AlgorithmsFactory();\n  return (\n    <inputDrawingsContext.Provider value={useInputDrawings()}>\n      <algorithmStepsContext.Provider value={useAlgorithmSteps()}>\n        <drawingModeContext.Provider value={useDrawingMode()}>\n          <div className=\"container\">\n            <div className=\"row\">\n              <div className=\"col-sm-3\">\n                <AlgorithmsList algorithms={algorithmFactory.getAll()} />\n              </div>\n              <div className=\"col-sm-6\">\n                <DrawingArea />\n                <StatesPlayer />\n              </div>\n              <div className=\"col-sm-3\">\n                <DrawingPalette buttons={drawingButtons} />\n              </div>\n            </div>\n          </div>\n        </drawingModeContext.Provider>\n      </algorithmStepsContext.Provider>\n    </inputDrawingsContext.Provider>\n  );\n}\n\nexport default App;\n","import React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport App from \"./components/App\";\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById(\"root\")\n);\n"],"sourceRoot":""}