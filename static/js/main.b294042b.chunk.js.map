{"version":3,"sources":["styles/button.module.scss","drawers/PointDrawer.ts","drawers/SegmentDrawer.ts","drawers/ColorsGenerator.ts","drawers/StepDrawer.ts","drawers/SceneDrawer.ts","utilities.ts","dataStructures/Point.ts","MouseEvents.ts","contexts/DrawingModeContext.ts","contexts/AlgorithmStepsContext.ts","contexts/InputDrawingsContext.ts","components/DrawingArea.tsx","components/Button.tsx","components/ButtonsList.tsx","components/DrawingPalette.tsx","components/StatesPlayer.tsx","components/AlgorithmsList.tsx","hooks/drawingMode.hook.ts","algorithms/step.ts","hooks/algorithmSteps.hook.ts","algorithms/simpleAlgorithm.ts","dataStructures/Segment.ts","dataStructures/Triagnle.ts","algorithms/extremePoints.ts","algorithms/algorithmsFactory.ts","hooks/inputDrawings.hook.ts","components/App.tsx","index.tsx"],"names":["module","exports","PointDrawer","points","scene","color","length","index","p","geometry","CircleGeometry","material","MeshBasicMaterial","circle","Mesh","position","setX","x","setY","y","add","SegmentDrawer","segments","segment","LineBasicMaterial","push","start","toVector2","end","BufferGeometry","setFromPoints","line","Line","ColorsGenerator","Math","floor","random","suggestedColorHex","getRandomColor","allColors","newColorHex","getNewRandomColorHex","Color","setHex","pointsGroupColors","segmentsGroupColors","getNewPointsGroupColor","getNewSegmentsGroupColor","getHex","Array","StepDrawer","pointDrawer","segmentDrawer","this","step","pointsGroups","segmentsGroups","pointsGroup","draw","getRandomPointsGroupColor","segmentsGroup","getRandomSegmentsGroupColor","SceneDrawer","stepDrawer","inputPoints","inputSegments","beingDrawenPoint","beingDrawenSegment","currentStep","remove","apply","children","getDefaultPointColor","getDefaultSegmentColor","doubleEqual","a","b","abs","Point","id","IDs","Vector2","MouseEvents","canvas","document","getElementById","mouseX","mouseY","rect","getBoundingClientRect","scaleX","width","scaleY","height","scaledPoint","left","top","drawingMode","e","button","getPoint","clientX","clientY","DEFAULT_DRAWING_MODE_VALUE","setCurrentDrawingMode","drawingModeContext","createContext","algorithmStepsContext","React","currentStepNumber","stepsCount","next","prev","run","algorithm","stop","isRunning","DEFAULT_INPUT_DRAWINGS_CONTEXT_VALUE","addPoint","point","addPoints","addSegment","addSegments","inputDrawingsContext","DrawingArea","myCanvas","useRef","useState","Scene","sceneDrawer","useMemo","mouseEvents","useContext","setBeingDrawenPoint","setBeingDrawenSegment","isDrawingStep","setIsDrawingStep","useEffect","renderer","WebGLRenderer","current","setClearColor","camera","OrthographicCamera","z","animate","requestAnimationFrame","render","generateRandom","n","maxHeight","maxWidth","randomX","randomY","generateRandomPoints","onMouseDown","res","Error","onMouseMove","onMouseLeave","ref","style","border","onClick","Button","props","backgroundColor","originalColor","myClasses","classNames","classes","myButton","clicked","isClicked","clickedColor","value","className","ButtonsList","buttons","setButtons","useCallback","find","newButtons","map","newButton","key","DrawingPalette","btn","StatesPlayer","startStopButton","type","display","justifyContent","disabled","marginTop","role","AlgorithmsList","algorithms","algo","Name","useDrawingMode","setDrawingMode","newDrawingMode","Step","i","j","equals","useAlgorithmSteps","currentIndex","setCurrentIndex","setCurrentStep","allSteps","setAllSteps","setIsRunning","setTimeout","firstStep","algorithmSteps","Run","steps","splice","cleanSteps","simpleAlgorithm","Segment","cross","Triangle","c","ab","bc","ca","onLeft","collinear","extremePointsAlgorithm","args","Set","arguments","size","elements","indices","indexOf","lst","sortedPoints","sort","less","uniquePoints","from","deletedPoints","deletedIndices","k","tri","unique","hasPointInside","hasPointOn","beforeDeleteStep","withoutIndices","afterDeleteStep","onlyStep","AlgorithmsFactory","useInputDrawings","setInputPoints","setInputSegments","drawingButtons","App","algorithmFactory","Provider","getAll","ReactDOM","StrictMode"],"mappings":"gGACAA,EAAOC,QAAU,CAAC,QAAU,wBAAwB,SAAW,yBAAyB,OAAS,yB,mJCE5EC,E,6FACdC,EAAiBC,EAAcC,GAClC,GAAsB,IAAlBF,EAAOG,OACX,IAAK,IAAIC,EAAQ,EAAGA,EAAQJ,EAAOG,OAAQC,IAAS,CAClD,IAAMC,EAAIL,EAAOI,GACXE,EAAW,IAAIC,IAAe,EAAG,IACjCC,EAAW,IAAIC,IAAkB,CAAEP,MAAOA,IAC1CQ,EAAS,IAAIC,IAAKL,EAAUE,GAClCE,EAAOE,SAASC,KAAKR,EAAES,GACvBJ,EAAOE,SAASG,KAAKV,EAAEW,GACvBf,EAAMgB,IAAIP,Q,KCHKQ,E,6FACdC,EAAqBlB,EAAcC,GACtC,GAAwB,IAApBiB,EAAShB,OAEb,IAAK,IAAIC,EAAQ,EAAGA,EAAQe,EAAShB,OAAQC,IAAS,CACpD,IAAMgB,EAAUD,EAASf,GACnBI,EAAW,IAAIa,IAAkB,CAAEnB,UAEnCF,EAAoB,GAC1BA,EAAOsB,KAAKF,EAAQG,MAAMC,aAC1BxB,EAAOsB,KAAKF,EAAQK,IAAID,aAExB,IAAMlB,GAAW,IAAIoB,KAAiBC,cAAc3B,GAE9C4B,EAAO,IAAIC,IAAKvB,EAAUE,GAChCP,EAAMgB,IAAIW,Q,KCvBKE,E,8GAMjB,OAAOC,KAAKC,MAAsB,SAAhBD,KAAKE,Y,6CAKvB,IADA,IAAIC,EAAoBJ,EAAgBK,iBACjCD,KAAqBJ,EAAgBM,WAC1CF,EAAoBJ,EAAgBK,iBAItC,OADAL,EAAgBM,UAAUF,GAAqBA,EACxCA,I,+CAIP,IAAMG,EAAcP,EAAgBQ,uBAC9BpC,EAAQ,IAAIqC,IAGlB,OAFArC,EAAMsC,OAAOH,GACbP,EAAgBW,kBAAkBnB,KAAKpB,GAChCA,I,iDAIP,IAAMmC,EAAcP,EAAgBQ,uBAC9BpC,EAAQ,IAAIqC,IAGlB,OAFArC,EAAMsC,OAAOH,GACbP,EAAgBY,oBAAoBpB,KAAKpB,GAClCA,I,gDAG+BE,GACtC,OAAI0B,EAAgBW,kBAAkBtC,OAASC,EACtC0B,EAAgBW,kBAAkBrC,GAElC0B,EAAgBa,2B,kDAIevC,GACxC,OAAI0B,EAAgBY,oBAAoBvC,OAASC,EACxC0B,EAAgBY,oBAAoBtC,GAEpC0B,EAAgBc,6B,6CAKzB,IAAM1C,EAAQ,IAAIqC,IAAM,OAExB,OADAT,EAAgBM,UAAUlC,EAAM2C,UAAY3C,EAAM2C,SAC3C3C,I,+CAIP,IAAMA,EAAQ,IAAIqC,IAAM,QAExB,OADAT,EAAgBM,UAAUlC,EAAM2C,UAAY3C,EAAM2C,SAC3C3C,M,KA5DU4B,EACJW,kBAA6B,IAAIK,MAD7BhB,EAEJY,oBAA+B,IAAII,MAF/BhB,EAGJM,UAAuC,G,ICCnCW,E,WAGnB,aAAe,yBAFfC,iBAEc,OADdC,mBACc,EACZC,KAAKF,YAAc,IAAIjD,EACvBmD,KAAKD,cAAgB,IAAI/B,E,iDAEtBiC,EAAYlD,GACf,GAAKkD,IAAUA,EAAKC,aAAajD,QAAWgD,EAAKE,eAAelD,QAAhE,CAGA,IAAK,IAAIC,EAAQ,EAAGA,EAAQ+C,EAAKC,aAAajD,OAAQC,IAAS,CAC7D,IAAMkD,EAAcH,EAAKC,aAAahD,GACtC8C,KAAKF,YAAYO,KACfD,EACArD,EACA6B,EAAgB0B,0BAA0BpD,IAI9C,IAAK,IAAIA,EAAQ,EAAGA,EAAQ+C,EAAKE,eAAelD,OAAQC,IAAS,CAC/D,IAAMqD,EAAgBN,EAAKE,eAAejD,GAC1C8C,KAAKD,cAAcM,KACjBE,EACAxD,EACA6B,EAAgB4B,4BAA4BtD,U,KCtB/BuD,E,iDACnBX,YAA2B,IAAIjD,E,KAC/BkD,cAA+B,IAAI/B,E,KACnC0C,WAAyB,IAAIb,E,iDAG3B9C,EACA4D,EACAC,EACAC,EACAC,EACAC,GAIAhE,EAAMiE,OAAOC,MAAMlE,EAAOA,EAAMmE,UAE5BH,EACFf,KAAKU,WAAWL,KAAKU,EAAahE,IAE9B8D,IACFF,EAAW,sBAAOA,GAAP,CAAoBE,KAE7BC,IACFF,EAAa,sBAAOA,GAAP,CAAsBE,KAErCd,KAAKF,YAAYO,KACfM,EACA5D,EACA6B,EAAgBuC,wBAElBnB,KAAKD,cAAcM,KACjBO,EACA7D,EACA6B,EAAgBwC,+B,KCrBXC,EAAc,SAACC,EAAWC,GACrC,OAAO1C,KAAK2C,IAAIF,EAAIC,GAHL,MCjBIE,E,WAKnB,WAAY7D,EAAWE,GAAY,yBAJnCF,OAIkC,OAHlCE,OAGkC,OAFlC4D,QAEkC,EAChC1B,KAAKpC,EAAIA,EACToC,KAAKlC,EAAIA,EACTkC,KAAK0B,GAAKD,EAAME,M,iDAEbJ,GACH,OAAIF,EAAYrB,KAAKpC,EAAG2D,EAAE3D,GACjBoC,KAAKlC,EAAIyD,EAAEzD,EAEbkC,KAAKpC,EAAI2D,EAAE3D,I,6BAEb2D,GACL,OAAOF,EAAYrB,KAAKpC,EAAG2D,EAAE3D,IAAMyD,EAAYrB,KAAKlC,EAAGyD,EAAEzD,K,kCAGzD,OAAO,IAAI8D,IAAQ5B,KAAKpC,EAAGoC,KAAKlC,O,KApBf2D,EAIZE,IAAc,E,ICJFE,E,WAEnB,aAAe,yBADfC,YACc,EACZ9B,KAAK8B,OAASC,SAASC,eACrB,+B,qDAGaC,EAAgBC,GAC/B,IAAMC,EAAOnC,KAAK8B,OAAOM,wBACnBC,EAASrC,KAAK8B,OAAOQ,MAAQH,EAAKG,MAClCC,EAASvC,KAAK8B,OAAOU,OAASL,EAAKK,OAEnCC,EAAc,IAAIhB,GACrBQ,EAASE,EAAKO,MAAQL,GACtBH,EAASC,EAAKQ,KAAOJ,GAOxB,OAJyB,IAAId,EAC3BgB,EAAY7E,EAAIoC,KAAK8B,OAAOQ,MAAQ,EACpCtC,KAAK8B,OAAOU,OAAS,EAAIC,EAAY3E,K,kCAKvC8E,EACAC,GAEA,OAAK7C,KAAK8B,QAAuB,IAAbe,EAAEC,QAEF,UAAhBF,EAEK,CADO5C,KAAK+C,SAASF,EAAEG,QAASH,EAAEI,SAC1B,KAAM,MAJoB,CAAC,KAAM,KAAM,Q,kCAUxDL,EACAC,GAEA,OAAK7C,KAAK8B,OACU,YAAhBc,EAAkC,CAAC,KAAM,KAAM,MAC/B,UAAhBA,EAEK,CADO5C,KAAK+C,SAASF,EAAEG,QAASH,EAAEI,SAC1B,KAAM,MAEhB,CAAC,KAAM,KAAM,MANK,CAAC,KAAM,KAAM,U,KCpC7BC,EAA6B,CACxCN,YAAa,QACbO,sBAAuB,cAGZC,EAAqBC,wBAChCH,GCyBWI,EAAwBC,IAAMF,cAhBiC,CAC1EtC,YAAa,KACbyC,mBAAoB,EACpBC,WAAY,EACZC,KAAM,aACNC,KAAM,aACNC,IAAK,SACHC,EACAlD,EACAC,KAEFvC,MAAO,aACPyF,KAAM,aACNC,WAAW,ICtBAC,EAA6D,CACxErD,YAAa,GACbC,cAAe,GACfqD,SAAU,SAACC,KACXC,UAAW,SAACrH,KACZsH,WAAY,SAAClG,KACbmG,YAAa,SAACpG,MAGHqG,EAAuBjB,wBAClCW,GCkHaO,MAxHf,WACE,IAAMC,EAAWC,iBALV1C,SAASC,eACd,gCAGmB,EAEL0C,mBAAgB,IAAIC,KAA7B5H,EAFc,oBAGf6H,EAAcC,mBAAQ,kBAAM,IAAIpE,IAAe,IAC/CqE,EAAcD,mBAAQ,kBAAM,IAAIhD,IAAe,IAC7Ce,EAAgBmC,qBAAW3B,GAA3BR,YACA7B,EAAgBgE,qBAAWzB,GAA3BvC,YANa,EAajBgE,qBAAWT,GALbL,EARmB,EAQnBA,SACAE,EATmB,EASnBA,UACAC,EAVmB,EAUnBA,WACAzD,EAXmB,EAWnBA,YACAC,EAZmB,EAYnBA,cAZmB,EAc2B8D,mBAAuB,MAdlD,mBAcd7D,EAdc,KAcImE,EAdJ,OAe+BN,mBAClD,MAhBmB,mBAed5D,EAfc,KAeMmE,EAfN,OAkBqBP,oBAAkB,GAlBvC,mBAkBdQ,EAlBc,KAkBCC,EAlBD,KAmBrBC,qBAAU,WACRD,EAAiC,OAAhBpE,KAChB,CAACA,IACJqE,qBAAU,WACR,IAAMC,EAAW,IAAIC,IAAc,CAAExD,OAAQ0C,EAASe,UACtDF,EAASG,cAAc,IAAInG,IAAM,UACjC,IAAMoG,EAAS,IAAIC,KAChBlB,EAASe,QAAQjD,MAAQ,EAC1BkC,EAASe,QAAQjD,MAAQ,EACzBkC,EAASe,QAAQ/C,OAAS,EAC1BgC,EAASe,QAAQ/C,QAAU,EAC3B,IACA,KAEFiD,EAAO/H,SAASiI,EAAI,GACpBb,EAAYhD,OAAS0C,EAASe,SACd,SAAVK,IACJC,sBAAsBD,GACtBP,EAASS,OAAO/I,EAAO0I,GAEzBG,KAEC,IAEHR,qBAAU,WACRR,EAAYvE,KACVtD,EACA4D,EACAC,EACAC,EACAC,EACAC,KAED,CACDJ,EACAC,EACAC,EACAC,EACA8D,EACA7H,EACAgE,IAGF,IA2BMgF,EAAiB,SAACC,GACtB,IAAMlJ,ENtG0B,SAClCkJ,EACAC,EACAC,GAGA,IADA,IAAMpJ,EAAkB,GACfI,EAAQ,EAAGA,EAAQ8I,EAAG9I,IAAS,CACtC,IAAMiJ,EAAUD,EAAWrH,KAAKE,SAAWmH,EAAW,EAChDE,EAAUH,EAAYpH,KAAKE,SAAWkH,EAAY,EACxDnJ,EAAOsB,KAAK,IAAIqD,EAAM0E,EAASC,IAGjC,OAAOtJ,EM0FUuJ,CACbL,EACAxB,EAASe,QAAQ/C,OACjBgC,EAASe,QAAQjD,OAEnB6B,EAAUrH,IAGZ,OACE,oCACE,4BACEwJ,YAvCc,SAAUzD,GAC5B,IAAIqC,EAAJ,CACA,IAAMqB,EAAMzB,EAAYwB,YAAY1D,EAAaC,GACjD,GAAmB,IAAf0D,EAAItJ,OACN,MAAMuJ,MAAM,8DACd,IAAMtC,EAAQqC,EAAI,GACZrI,EAAUqI,EAAI,GAChBrC,GAAOD,EAASC,GAChBhG,GAASkG,EAAWlG,KAgCpBuI,YA7Bc,SAAU5D,GAC5B,IAAIqC,EAAJ,CACA,IAAMqB,EAAMzB,EAAY2B,YAAY7D,EAAaC,GACjD,GAAmB,IAAf0D,EAAItJ,OACN,MAAMuJ,MAAM,8DACd,IAAMtC,EAAQqC,EAAI,GACZrI,EAAUqI,EAAI,GAChBrC,GAAOc,EAAoBd,GAC3BhG,GAAS+G,EAAsB/G,KAsB/BwI,aAnBe,WACnB1B,EAAoB,MACpBC,EAAsB,OAkBlB0B,IAAKnC,EACLlC,MAAM,MACNE,OAAO,MACPoE,MAAO,CAAEC,OAAQ,qBAGnB,uDAEE,4BAAQC,QAAS,kBAAMf,EAAe,MAAtC,MACA,4BAAQe,QAAS,kBAAMf,EAAe,OAAtC,OACA,4BAAQe,QAAS,kBAAMf,EAAe,OAAtC,W,gDCjGOgB,MAtBf,SAAgBC,GAAqB,IAAD,EAC5BJ,EAAQ,CACZK,gBAAiBD,EAAME,eAEnBC,EAAYC,KAAU,mBACzBC,IAAQC,UAAW,GADM,cAEzBD,IAAQE,QAAUP,EAAMQ,WAFC,IAW5B,OANIR,EAAMQ,YACRZ,EAAMK,gBAAkBD,EAAMS,cAM9B,4BAAQb,MAAOA,EAAOE,QAJR,WACTE,EAAMQ,WAAWR,EAAMF,QAAQE,EAAMU,QAGFC,UAAWR,GAChDH,EAAMU,QCtBPE,EAAc,SAAUZ,GAAe,IAAD,EACZtC,mBAAwB,IADZ,mBACnCmD,EADmC,KAC1BC,EAD0B,KAG1C1C,qBAAU,WACR0C,EAAWd,EAAMa,WAChB,CAACb,EAAMa,UAEV,IAAMf,EAAUiB,uBACd,SAAUL,GAER,IAAM5E,EAAS+E,EAAQG,MAAK,SAACzG,GAAD,OAAoBA,EAAEmG,QAAUA,KAC5D,IAAK5E,EAAQ,MAAM0D,MAAM,SAAD,OAAUkB,EAAV,oBAExB,GAAI5E,EAAO0E,UACT,MAAMhB,MAAM,wEAId,IAAMyB,EAAaJ,EAAQK,KAAI,SAACpF,GAAD,OAC7BA,EAAO4E,QAAUA,EAAjB,2BACS5E,GADT,IACiB0E,WAAW,IAD5B,2BAES1E,GAFT,IAEiB0E,WAAW,OAE9BM,EAAWG,KAEb,CAACJ,IAGH,OACE,6BACGA,EAAQK,KAAI,SAACpF,GACZ,IAAMqF,EAAS,2BACVrF,GADU,IAEbgE,QAAS,SAACY,GACRZ,EAAQY,GACR5E,EAAOgE,QAAQY,MAGnB,OAAO,kBAAC,EAAD,eAAQU,IAAKD,EAAUT,OAAWS,SCVlCE,MA1Bf,SAAwBrB,GAAe,IAAD,EACWzD,IAAMwB,WACnD3B,GADMR,EAD4B,EAC5BA,YAAaO,EADe,EACfA,sBAIf2D,EAAUiB,uBACd,SAAUL,GACRvE,EAAsBuE,KAExB,CAACvE,IAGG0E,EAAUb,EAAMa,QAAQK,KAAI,SAACI,GAAD,OAChCA,EAAIZ,QAAU9E,EAAd,2BACS0F,GADT,IACcxB,UAASU,WAAW,IADlC,2BAESc,GAFT,IAEcxB,eAGhB,OACE,yBAAKa,UAAU,sBACb,kBAAC,EAAD,CAAaE,QAASA,IACtB,8BAAOjF,KC3BA2F,G,MAAe,WAAa,IAAD,EASlCxD,qBAAWzB,GAPbG,EAFoC,EAEpCA,WACAD,EAHoC,EAGpCA,kBACAE,EAJoC,EAIpCA,KACAC,EALoC,EAKpCA,KACAtF,EANoC,EAMpCA,MACA0F,EAPoC,EAOpCA,UACAD,EARoC,EAQpCA,KAEI0E,EAAkBzE,EACtB,4BAAQ0E,KAAK,SAASd,UAAU,kBAAkBb,QAAShD,GACxD,QAGH,4BAAQ2E,KAAK,SAASd,UAAU,kBAAkBb,QAASzI,GACxD,SAGL,OAAmB,IAAfoF,EAAyB,qCAE3B,oCACE,6BACA,8BACGD,EADH,MACyBC,EAAa,GAEtC,yBAAKmD,MAAO,CAAE8B,QAAS,OAAQC,eAAgB,WAI7C,4BACEF,KAAK,SACLd,UAAU,kBACVb,QAASnD,EACTiF,SAAgC,IAAtBpF,GAET,KAEFgF,EACD,4BACEC,KAAK,SACLd,UAAU,kBACVb,QAASpD,EACTkF,SAAUpF,IAAsBC,EAAa,GAE5C,MAML,yBAAKkE,UAAU,WAAWf,MAAO,CAAEiC,UAAW,KAC5C,yBACElB,UAAU,0DACVmB,KAAK,cACLlC,MAAO,CACLtE,MAAM,GAAD,OAAM,IAAMkB,GAAsBC,EAAa,GAA/C,YC1BFsF,EAxBQ,SAAU/B,GAAiC,IACxDpD,EAAQmB,qBAAWzB,GAAnBM,IADuD,EAExBmB,qBAAWT,GAA1C3D,EAFuD,EAEvDA,YAAaC,EAF0C,EAE1CA,cACfkG,EAAU,SAAUY,GACxB,IAAM7D,EAAYmD,EAAMgC,WAAWhB,MAAK,SAACiB,GAAD,OAAUA,EAAKC,SAAWxB,KAClE,IAAK7D,EAAW,MAAM2C,MAAM,aAAD,OAAckB,EAAd,mBAC3B9D,EAAIC,EAAWlD,EAAaC,IAExBiH,EAAUb,EAAMgC,WAAWd,KAAI,SAACrE,GAAD,MAAgB,CACnD6D,MAAO7D,EAAUqF,OAEjBzB,aAAc,WACdP,cAAe,YACfM,WAAW,EACXV,QAASA,MAEX,OACE,oCACE,0CACA,kBAAC,EAAD,CAAae,QAASA,MCtBfsB,EAAiB,WAA2B,IAAD,EAChBzE,mBACpCxB,EAA2BN,aAFyB,mBAC/CA,EAD+C,KAClCwG,EADkC,KAStD,MAAO,CACLxG,cACAO,sBAN4B4E,uBAAY,SAACsB,GACzCD,EAAeC,KACd,MCVgBC,E,WAGnB,aAAe,yBAFfpJ,kBAEc,OADdC,oBACc,EACZH,KAAKE,aAAe,IAAIN,MACxBI,KAAKG,eAAiB,IAAIP,M,mDAErBK,GACL,GACED,KAAKE,aAAajD,SAAWgD,EAAKC,aAAajD,QAC/C+C,KAAKG,eAAelD,SAAWgD,EAAKE,eAAelD,OAEnD,OAAO,EAET,IAAK,IAAIsM,EAAI,EAAGA,EAAIvJ,KAAKE,aAAajD,OAAQsM,IAAK,CACjD,GAAIvJ,KAAKE,aAAaqJ,GAAGtM,SAAWgD,EAAKC,aAAaqJ,GAAGtM,OACvD,OAAO,EAET,IAAK,IAAIuM,EAAI,EAAGA,EAAIxJ,KAAKE,aAAaqJ,GAAGtM,OAAQuM,IAAK,CAEpD,IADcxJ,KAAKE,aAAaqJ,GAAGC,GACxBC,OAAOxJ,EAAKC,aAAaqJ,GAAGC,IAAK,OAAO,GAIvD,IAAK,IAAID,EAAI,EAAGA,EAAIvJ,KAAKG,eAAelD,OAAQsM,IAAK,CACnD,GAAIvJ,KAAKG,eAAeoJ,GAAGtM,SAAWgD,EAAKE,eAAeoJ,GAAGtM,OAC3D,OAAO,EACT,IAAK,IAAIuM,EAAI,EAAGA,EAAIxJ,KAAKG,eAAeoJ,GAAGtM,OAAQuM,IAAK,CAEtD,IADgBxJ,KAAKG,eAAeoJ,GAAGC,GAC1BC,OAAOxJ,EAAKE,eAAeoJ,GAAGC,IAAK,OAAO,GAG3D,OAAO,M,KC5BEE,EAAoB,WAA8B,IAAD,EACpBhF,oBAAU,GADU,mBACrDiF,EADqD,KACvCC,EADuC,OAEtBlF,mBAAsB,MAFA,mBAErD3D,EAFqD,KAExC8I,EAFwC,OAG5BnF,mBAAiB,IAHW,mBAGrDoF,EAHqD,KAG3CC,EAH2C,OAI1BrF,oBAAkB,GAJQ,mBAIrDX,EAJqD,KAI1CiG,EAJ0C,KAMtDtG,EAAOqE,uBAAY,WACnB4B,IAAiBG,EAAS7M,OAAS,IACvC4M,EAAeC,EAASH,EAAe,IACvCC,EAAgBD,EAAe,MAC9B,CAACG,EAAUH,IAEdvE,qBAAU,WACHrB,GACLkG,YAAW,WACTvG,MACC,OAKF,CAACK,EAAW4F,IA0Cf,MAAO,CACL5I,cACAyC,kBAAmBmG,EACnBlG,WAAYqG,EAAS7M,OACrByG,OACAC,KA7CW,WACU,IAAjBgG,IACJE,EAAeC,EAASH,EAAe,IACvCC,EAAgBD,EAAe,KA2C/B/F,IA9BU,SACVC,EACAlD,EACAC,GAEA,IAAMsJ,EAAY,IAAIZ,EACtBY,EAAUhK,aAAe,CAACS,GAC1BuJ,EAAU/J,eAAiB,CAACS,GAC5B,IAAMuJ,EAAiBtG,EAAUuG,IAAIzJ,EAAaC,GAC5CyJ,EAAK,CAAIH,GAAJ,mBAAkBC,KAnBZ,SAAUE,GAC3B,IAAK,IAAInN,EAAQ,EAAGA,EAAQmN,EAAMpN,OAAQC,IAAS,CACpCmN,EAAMnN,GACVuM,OAAOY,EAAMnN,EAAQ,MAC5BmN,EAAMC,OAAOpN,EAAO,GACpBA,MAeJqN,CAAWF,GACXN,EAAYM,GACZR,EAAeQ,EAAM,IACrBT,EAAgB,IAkBhB9F,KAfW,WACXkG,GAAa,IAebjG,YACA1F,MAbY,WACZ2L,GAAa,MC9DIQ,E,4FACf7J,EAAsBC,GAMxB,OALcD,EAAYuH,KAAI,SAAChE,GAC7B,IAAMjE,EAAO,IAAIqJ,EAEjB,OADArJ,EAAKC,aAAa9B,KAAK,CAAC8F,IACjBjE,O,6BAKT,MAAO,a,KCbUwK,E,WAKnB,WAAYpM,EAAcE,GAAa,yBAJvCF,WAIsC,OAHtCE,SAGsC,OAFtCmD,QAEsC,EACpC1B,KAAK3B,MAAQA,EACb2B,KAAKzB,IAAMA,EACXyB,KAAK0B,GAAKD,EAAME,M,sDAIhB,OAAO,IAAI8I,EAAQzK,KAAKzB,IAAKyB,KAAK3B,S,4BAG9BlB,GACJ,OACG6C,KAAKzB,IAAIX,EAAIoC,KAAK3B,MAAMT,IAAMT,EAAEW,EAAIkC,KAAK3B,MAAMP,IAC/CkC,KAAKzB,IAAIT,EAAIkC,KAAK3B,MAAMP,IAAMX,EAAES,EAAIoC,KAAK3B,MAAMT,K,6BAI7CT,GACL,OAAO6C,KAAK0K,MAAMvN,GAAK,I,gCAGfA,GACR,OAAyB,IAAlB6C,KAAK0K,MAAMvN,K,6BAGbe,GACL,OAAO8B,KAAK3B,MAAMoL,OAAOvL,EAAQG,QAAU2B,KAAKzB,IAAIkL,OAAOvL,EAAQK,S,KA/BlDkM,EAIZ9I,IAAc,E,ICHFgJ,E,WAUnB,WAAYrJ,EAAUC,EAAUqJ,GAAW,yBAT3CtJ,OAS0C,OAR1CC,OAQ0C,OAP1CqJ,OAO0C,OAN1CC,QAM0C,OAL1CC,QAK0C,OAJ1CC,QAI0C,OAH1CrJ,QAG0C,EACxC1B,KAAKsB,EAAIA,EACTtB,KAAKuB,EAAIA,EACTvB,KAAK4K,EAAIA,EACT5K,KAAK6K,GAAK,IAAIJ,EAAQnJ,EAAGC,GACzBvB,KAAK8K,GAAK,IAAIL,EAAQlJ,EAAGqJ,GACzB5K,KAAK+K,GAAK,IAAIN,EAAQG,EAAGtJ,GACzBtB,KAAK0B,GAAKiJ,EAAShJ,M,2DAGNxE,GACb,OAAO6C,KAAK6K,GAAGG,OAAO7N,IAAM6C,KAAK8K,GAAGE,OAAO7N,IAAM6C,KAAK+K,GAAGC,OAAO7N,K,iCAGvDA,GACT,OAAO6C,KAAK6K,GAAGI,UAAU9N,IAAM6C,KAAK8K,GAAGG,UAAU9N,IAAM6C,KAAK+K,GAAGE,UAAU9N,O,KAzBxDwN,EAQZhJ,IAAc,E,ICJFuJ,E,iGACe,IAAD,uBAApBC,EAAoB,yBAApBA,EAAoB,gBAC/B,OAAO,IAAIC,IAAIC,WAAWC,OAASD,UAAUpO,S,qCAG7BsO,EAAeC,GAE/B,IADA,IAAMjF,EAAW,GACRrJ,EAAQ,EAAGA,EAAQqO,EAAStO,OAAQC,KACX,IAA5BsO,EAAQC,QAAQvO,IAClBqJ,EAAInI,KAAKmN,EAASrO,IAGtB,OAAOqJ,I,0BAGL5F,EAAsBC,GAAmC,IlBIjB8K,EkBJgB,OACpDC,EAAehL,EAAYiL,MAAK,SAACtK,EAAUC,GAC/C,OAAID,EAAEuK,KAAKtK,IAAY,EACdD,EAAEmI,OAAOlI,GAAW,EAEjB,KAGRuK,GlBJoCJ,EkBIHC,ElBHlC/L,MAAMmM,KAAK,IAAIX,IAAIM,KkBKxB,GAAII,EAAa7O,OAAS,GACI,IAAxB6O,EAAa7O,OAAc,CAC7B,IAAMgD,EAAO,IAAIqJ,EAKjB,OAJArJ,EAAKE,eAAe/B,KAAK,CAEvB,IAAIqM,EAAQ,IAAIhJ,EAAM,EAAG,GAAI,IAAIA,EAAM,EAAG,MAErC,CAACxB,GASZ,IALA,IAAMoK,EAAgB,GAEhB2B,EAAyB,GACzBC,EAA2B,GAxByB,WA0BjD1C,GACP,GAAI0C,EAAejE,MAAK,SAACpK,GAAD,OAAOA,IAAM2L,KAAI,iBACzC,IA5BwD,eA4B/CC,GACP,GAAIyC,EAAejE,MAAK,SAACpK,GAAD,OAAOA,IAAM4L,KAAI,iBACzC,IA9BsD,eA8B7C0C,GACP,GAAID,EAAejE,MAAK,SAACpK,GAAD,OAAOA,IAAMsO,KAAI,iBAOzC,IANA,IAAMC,EAAM,IAAIxB,EACdmB,EAAavC,GACbuC,EAAatC,GACbsC,EAAaI,IAnCqC,WAsC3CvG,GACP,IAAK,EAAKyG,OAAO7C,EAAGC,EAAG0C,EAAGvG,GAAI,iBAC9B,GAAIsG,EAAejE,MAAK,SAACpK,GAAD,OAAOA,IAAM+H,KAAI,iBAEzC,IAAMxI,EAAI2O,EAAanG,GAEvB,IAAKxI,EAAEsM,OAAO0C,EAAI7K,KAAOnE,EAAEsM,OAAO0C,EAAI5K,KAAOpE,EAAEsM,OAAO0C,EAAIvB,KACpDuB,EAAIE,eAAelP,IAAMgP,EAAIG,WAAWnP,IAAI,CAC9C,IAAMoP,EAAmB,IAAIjD,EAC7BiD,EAAiBpM,eAAiB,CAAC,CAACgM,EAAItB,GAAIsB,EAAIrB,GAAIqB,EAAIpB,KACxDwB,EAAiBrM,aAAe,CAC9B,EAAKsM,eAAeV,EAAcG,GAClC,CAAC9O,IAEC6O,EAAc5N,KAAK0N,EAAanG,IACxCsG,EAAe7N,KAAKuH,GAEhB,IAAM8G,EAAkB,IAAInD,EAC5BmD,EAAgBtM,eAAiB,CAAC,CAACgM,EAAItB,GAAIsB,EAAIrB,GAAIqB,EAAIpB,KACvD0B,EAAgBvM,aAAe,CAC7B,EAAKsM,eAAeV,EAAcG,IAGpC5B,EAAMjM,KAAKmO,GACXlC,EAAMjM,KAAKqO,KAxBR9G,EAAI,EAAGA,EAAImG,EAAa7O,OAAQ0I,IAAK,EAArCA,IARFuG,EAAI,EAAGA,EAAIJ,EAAa7O,OAAQiP,IAAK,EAArCA,IAFF1C,EAAI,EAAGA,EAAIsC,EAAa7O,OAAQuM,IAAK,EAArCA,IAFFD,EAAI,EAAGA,EAAIuC,EAAa7O,OAAQsM,IAAK,EAArCA,GA2CT,IAAMmD,EAAW,IAAIpD,EAGrB,OAFAoD,EAASxM,aAAe,CAACF,KAAKwM,eAAeV,EAAcG,IAErD,GAAN,OAAW5B,EAAX,CAAkBqC,M,6BAGlB,MAAO,qB,KC7FUC,E,WAEnB,aAAe,yBADf3D,gBACc,EACZhJ,KAAKgJ,WAAa,CAAC,IAAIwB,EAAmB,IAAIU,G,qDAG9C,OAAOlL,KAAKgJ,e,KCFH4D,EAAmB,WAA6B,IAAD,EACpBlI,mBACpCV,EAAqCrD,aAFmB,mBACnDA,EADmD,KACtCkM,EADsC,OAKhBnI,mBACxCV,EAAqCpD,eANmB,mBAKnDA,EALmD,KAKpCkM,EALoC,KA0C1D,MAAO,CACL7I,SAlCe8D,uBACf,SAAC7D,GACC2I,EAAe,GAAD,mBAAKlM,GAAL,CAAkBuD,OAElC,CAACvD,IA+BDwD,UA5BgB4D,uBAChB,SAACjL,GACC+P,EAAe,GAAD,mBAAKlM,GAAL,YAAqB7D,OAErC,CAAC6D,IAyBDyD,WAtBiB2D,uBACjB,SAAC7J,GACC4O,EAAiB,GAAD,mBAAKlM,GAAL,CAAoB1C,OAEtC,CAAC0C,IAmBDyD,YAhBkB0D,uBAClB,SAAC9J,GACC6O,EAAiB,GAAD,mBAAKlM,GAAL,YAAuB3C,OAEzC,CAAC2C,IAaDD,cACAC,kBCzCEmM,EACQ,CACV,CACEvF,WAAW,EACXE,MAAO,UACPR,cAAe,YACfO,aAAc,QAEhB,CACED,WAAW,EACXE,MAAO,QACPR,cAAe,UACfO,aAAc,WAEhB,CACED,WAAW,EACXE,MAAO,OACPR,cAAe,UACfO,aAAc,WAEhB,CACED,WAAW,EACXE,MAAO,UACPR,cAAe,UACfO,aAAc,UAgCLuF,MA1Bf,WACE,IAAMC,EAAmB,IAAIN,EAC7B,OACE,kBAACrI,EAAqB4I,SAAtB,CAA+BxF,MAAOkF,KACpC,kBAACtJ,EAAsB4J,SAAvB,CAAgCxF,MAAOgC,KACrC,kBAACtG,EAAmB8J,SAApB,CAA6BxF,MAAOyB,KAClC,yBAAKxB,UAAU,aACb,yBAAKA,UAAU,OACb,yBAAKA,UAAU,YACb,kBAAC,EAAD,CAAgBqB,WAAYiE,EAAiBE,YAE/C,yBAAKxF,UAAU,YACb,kBAAC,EAAD,MACA,kBAAC,EAAD,OAEF,yBAAKA,UAAU,YACb,kBAAC,EAAD,CAAgBE,QAASkF,WCzDzCK,IAAStH,OACP,kBAAC,IAAMuH,WAAP,KACE,kBAAC,EAAD,OAEFtL,SAASC,eAAe,W","file":"static/js/main.b294042b.chunk.js","sourcesContent":["// extracted by mini-css-extract-plugin\nmodule.exports = {\"clicked\":\"button_clicked__R6E18\",\"myButton\":\"button_myButton__2Rz3z\",\"wiggle\":\"button_wiggle__3rqZd\"};","import Point from \"../dataStructures/Point\";\nimport { Scene, Mesh, CircleGeometry, MeshBasicMaterial, Color } from \"three\";\n\nexport default class PointDrawer {\n  draw(points: Point[], scene: Scene, color: Color) {\n    if (points.length === 0) return;\n    for (let index = 0; index < points.length; index++) {\n      const p = points[index];\n      const geometry = new CircleGeometry(2, 10);\n      const material = new MeshBasicMaterial({ color: color });\n      const circle = new Mesh(geometry, material);\n      circle.position.setX(p.x);\n      circle.position.setY(p.y);\n      scene.add(circle);\n    }\n  }\n}\n","import Segment from \"../dataStructures/Segment\";\nimport {\n  Scene,\n  LineBasicMaterial,\n  BufferGeometry,\n  Vector2,\n  Line,\n  Color,\n} from \"three\";\n\nexport default class SegmentDrawer {\n  draw(segments: Segment[], scene: Scene, color: Color): void {\n    if (segments.length === 0) return;\n\n    for (let index = 0; index < segments.length; index++) {\n      const segment = segments[index];\n      const material = new LineBasicMaterial({ color });\n\n      const points: Vector2[] = [];\n      points.push(segment.start.toVector2());\n      points.push(segment.end.toVector2());\n\n      const geometry = new BufferGeometry().setFromPoints(points);\n\n      const line = new Line(geometry, material);\n      scene.add(line);\n    }\n  }\n}\n","import { Color } from \"three\";\n\nexport default class ColorsGenerator {\n  private static pointsGroupColors: Color[] = new Array<Color>();\n  private static segmentsGroupColors: Color[] = new Array<Color>();\n  private static allColors: { [key: number]: number } = {};\n\n  private static getRandomColor(): number {\n    return Math.floor(Math.random() * 0xffffff);\n  }\n\n  private static getNewRandomColorHex(): number {\n    let suggestedColorHex = ColorsGenerator.getRandomColor();\n    while (suggestedColorHex in ColorsGenerator.allColors) {\n      suggestedColorHex = ColorsGenerator.getRandomColor();\n    }\n\n    ColorsGenerator.allColors[suggestedColorHex] = suggestedColorHex;\n    return suggestedColorHex;\n  }\n\n  private static getNewPointsGroupColor(): Color {\n    const newColorHex = ColorsGenerator.getNewRandomColorHex();\n    const color = new Color();\n    color.setHex(newColorHex);\n    ColorsGenerator.pointsGroupColors.push(color);\n    return color;\n  }\n\n  private static getNewSegmentsGroupColor(): Color {\n    const newColorHex = ColorsGenerator.getNewRandomColorHex();\n    const color = new Color();\n    color.setHex(newColorHex);\n    ColorsGenerator.segmentsGroupColors.push(color);\n    return color;\n  }\n\n  public static getRandomPointsGroupColor(index: number): Color {\n    if (ColorsGenerator.pointsGroupColors.length > index)\n      return ColorsGenerator.pointsGroupColors[index];\n    else {\n      return ColorsGenerator.getNewPointsGroupColor();\n    }\n  }\n\n  public static getRandomSegmentsGroupColor(index: number): Color {\n    if (ColorsGenerator.segmentsGroupColors.length > index)\n      return ColorsGenerator.segmentsGroupColors[index];\n    else {\n      return ColorsGenerator.getNewSegmentsGroupColor();\n    }\n  }\n\n  public static getDefaultPointColor(): Color {\n    const color = new Color(\"red\");\n    ColorsGenerator.allColors[color.getHex()] = color.getHex();\n    return color;\n  }\n\n  public static getDefaultSegmentColor(): Color {\n    const color = new Color(\"blue\");\n    ColorsGenerator.allColors[color.getHex()] = color.getHex();\n    return color;\n  }\n}\n","import { Scene } from \"three\";\nimport Step from \"../algorithms/step\";\nimport PointDrawer from \"./PointDrawer\";\nimport SegmentDrawer from \"./SegmentDrawer\";\nimport ColorsGenerator from \"./ColorsGenerator\";\n\nexport default class StepDrawer {\n  pointDrawer: PointDrawer;\n  segmentDrawer: SegmentDrawer;\n  constructor() {\n    this.pointDrawer = new PointDrawer();\n    this.segmentDrawer = new SegmentDrawer();\n  }\n  draw(step: Step, scene: Scene) {\n    if (!step || (!step.pointsGroups.length && !step.segmentsGroups.length))\n      return;\n\n    for (let index = 0; index < step.pointsGroups.length; index++) {\n      const pointsGroup = step.pointsGroups[index];\n      this.pointDrawer.draw(\n        pointsGroup,\n        scene,\n        ColorsGenerator.getRandomPointsGroupColor(index)\n      );\n    }\n\n    for (let index = 0; index < step.segmentsGroups.length; index++) {\n      const segmentsGroup = step.segmentsGroups[index];\n      this.segmentDrawer.draw(\n        segmentsGroup,\n        scene,\n        ColorsGenerator.getRandomSegmentsGroupColor(index)\n      );\n    }\n  }\n}\n","import PointDrawer from \"./PointDrawer\";\nimport { Scene } from \"three\";\nimport SegmentDrawer from \"./SegmentDrawer\";\nimport Segment from \"../dataStructures/Segment\";\nimport Point from \"../dataStructures/Point\";\nimport Step from \"../algorithms/step\";\nimport StepDrawer from \"./StepDrawer\";\nimport ColorsGenerator from \"./ColorsGenerator\";\n\nexport default class SceneDrawer {\n  pointDrawer: PointDrawer = new PointDrawer();\n  segmentDrawer: SegmentDrawer = new SegmentDrawer();\n  stepDrawer: StepDrawer = new StepDrawer();\n\n  draw(\n    scene: Scene,\n    inputPoints: Point[],\n    inputSegments: Segment[],\n    beingDrawenPoint: Point | null,\n    beingDrawenSegment: Segment | null,\n    currentStep: Step | null\n  ) {\n    //TODO: Do that more efficiently\n    //clearScene\n    scene.remove.apply(scene, scene.children);\n\n    if (currentStep) {\n      this.stepDrawer.draw(currentStep, scene);\n    } else {\n      if (beingDrawenPoint) {\n        inputPoints = [...inputPoints, beingDrawenPoint];\n      }\n      if (beingDrawenSegment) {\n        inputSegments = [...inputSegments, beingDrawenSegment];\n      }\n      this.pointDrawer.draw(\n        inputPoints,\n        scene,\n        ColorsGenerator.getDefaultPointColor()\n      );\n      this.segmentDrawer.draw(\n        inputSegments,\n        scene,\n        ColorsGenerator.getDefaultSegmentColor()\n      );\n    }\n  }\n}\n","import Point from \"./dataStructures/Point\";\n\n/*\nIt is assumed here that coordinates plane start from -maxWidth/2 to maxWidth/2 and from -maxHeight/2 to maxHeight/2\n*/\nexport const generateRandomPoints = (\n  n: number,\n  maxHeight: number,\n  maxWidth: number\n): Point[] => {\n  const points: Point[] = [];\n  for (let index = 0; index < n; index++) {\n    const randomX = maxWidth * Math.random() - maxWidth / 2;\n    const randomY = maxHeight * Math.random() - maxHeight / 2;\n    points.push(new Point(randomX, randomY));\n  }\n\n  return points;\n};\n\nexport const E = 1e-5;\n\nexport const doubleEqual = (a: number, b: number): boolean => {\n  return Math.abs(a - b) < E;\n};\n\nexport const getUniqueElements = function <T>(lst: T[]): T[] {\n  return Array.from(new Set(lst));\n};\n","import { Vector2 } from \"three\";\nimport { doubleEqual } from \"../utilities\";\n\nexport default class Point {\n  x: number;\n  y: number;\n  id: number;\n  static IDs: number = 0;\n  constructor(x: number, y: number) {\n    this.x = x;\n    this.y = y;\n    this.id = Point.IDs++;\n  }\n  less(b: Point): boolean {\n    if (doubleEqual(this.x, b.x)) {\n      return this.y < b.y;\n    }\n    return this.x < b.x;\n  }\n  equals(b: Point): boolean {\n    return doubleEqual(this.x, b.x) && doubleEqual(this.y, b.y);\n  }\n  toVector2() {\n    return new Vector2(this.x, this.y);\n  }\n}\n","import Point from \"./dataStructures/Point\";\nimport Segment from \"./dataStructures/Segment\";\n\nexport default class MouseEvents {\n  canvas: HTMLCanvasElement;\n  constructor() {\n    this.canvas = document.getElementById(\n      \"element that does not exist\"\n    ) as HTMLCanvasElement;\n  }\n  private getPoint(mouseX: number, mouseY: number): Point {\n    const rect = this.canvas.getBoundingClientRect();\n    const scaleX = this.canvas.width / rect.width;\n    const scaleY = this.canvas.height / rect.height;\n\n    const scaledPoint = new Point(\n      (mouseX - rect.left) * scaleX,\n      (mouseY - rect.top) * scaleY\n    );\n\n    const transformedPoint = new Point(\n      scaledPoint.x - this.canvas.width / 2,\n      this.canvas.height / 2 - scaledPoint.y\n    );\n    return transformedPoint;\n  }\n  onMouseDown(\n    drawingMode: string,\n    e: React.MouseEvent\n  ): (Point | Segment | /*Polygon |*/ null)[] {\n    if (!this.canvas || e.button !== 0) return [null, null, null];\n\n    if (drawingMode === \"Point\") {\n      const point = this.getPoint(e.clientX, e.clientY);\n      return [point, null, null];\n    }\n\n    return [null, null, null];\n  }\n  onMouseMove(\n    drawingMode: string,\n    e: React.MouseEvent\n  ): (Point | Segment | /*Polygon |*/ null)[] {\n    if (!this.canvas) return [null, null, null];\n    if (drawingMode === \"Nothing\") return [null, null, null];\n    if (drawingMode === \"Point\") {\n      const point = this.getPoint(e.clientX, e.clientY);\n      return [point, null, null];\n    }\n    return [null, null, null];\n  }\n}\n","import { createContext } from \"react\";\n\nexport interface DrawingModeContext {\n  drawingMode: string;\n  setCurrentDrawingMode: (currentDrawingMode: string) => void;\n}\n\nexport const DEFAULT_DRAWING_MODE_VALUE = {\n  drawingMode: \"Point\",\n  setCurrentDrawingMode: () => {},\n};\n\nexport const drawingModeContext = createContext<DrawingModeContext>(\n  DEFAULT_DRAWING_MODE_VALUE\n);\n","import React from \"react\";\nimport Step from \"../algorithms/step\";\nimport IAlgorithm from \"../algorithms/IAlgorithm\";\nimport Point from \"../dataStructures/Point\";\nimport Segment from \"../dataStructures/Segment\";\n\nexport interface AlgorithmStepsContext {\n  currentStep: Step | null;\n  currentStepNumber: number;\n  stepsCount: number;\n  next: () => void;\n  prev: () => void;\n  run: (\n    algorithm: IAlgorithm,\n    inputPoints: Point[],\n    inputSegments: Segment[]\n  ) => void;\n  start: () => void;\n  stop: () => void;\n  isRunning: boolean;\n}\n\nexport const DEFAULT_ALGORITHM_STEPS_CONTEXT_VALUE: AlgorithmStepsContext = {\n  currentStep: null,\n  currentStepNumber: -1,\n  stepsCount: 0,\n  next: () => {},\n  prev: () => {},\n  run: (\n    algorithm: IAlgorithm,\n    inputPoints: Point[],\n    inputSegments: Segment[]\n  ) => {},\n  start: () => {},\n  stop: () => {},\n  isRunning: false,\n};\n\nexport const algorithmStepsContext = React.createContext<AlgorithmStepsContext>(\n  DEFAULT_ALGORITHM_STEPS_CONTEXT_VALUE\n);\n","import { createContext } from \"react\";\nimport Point from \"../dataStructures/Point\";\nimport Segment from \"../dataStructures/Segment\";\n\nexport interface InputDrawingsContext {\n  inputPoints: Point[];\n  inputSegments: Segment[];\n  addPoint: (point: Point) => void;\n  addPoints: (points: Point[]) => void;\n  addSegment: (segment: Segment) => void;\n  addSegments: (segments: Segment[]) => void;\n}\n\nexport const DEFAULT_INPUT_DRAWINGS_CONTEXT_VALUE: InputDrawingsContext = {\n  inputPoints: [],\n  inputSegments: [],\n  addPoint: (point: Point) => {},\n  addPoints: (points: Point[]) => {},\n  addSegment: (segment: Segment) => {},\n  addSegments: (segments: Segment[]) => {},\n};\n\nexport const inputDrawingsContext = createContext<InputDrawingsContext>(\n  DEFAULT_INPUT_DRAWINGS_CONTEXT_VALUE\n);\n","import React, { useRef, useEffect, useState, useMemo, useContext } from \"react\";\nimport { WebGLRenderer, Scene, OrthographicCamera, Color } from \"three\";\nimport Point from \"../dataStructures/Point\";\nimport Segment from \"../dataStructures/Segment\";\nimport SceneDrawer from \"../drawers/SceneDrawer\";\nimport MouseEvents from \"../MouseEvents\";\nimport { drawingModeContext } from \"../contexts/DrawingModeContext\";\nimport { algorithmStepsContext } from \"../contexts/AlgorithmStepsContext\";\nimport { inputDrawingsContext } from \"../contexts/InputDrawingsContext\";\nimport { generateRandomPoints } from \"../utilities\";\n\n//FIXME: We should not need that.\nfunction getTempCanvas(): HTMLCanvasElement {\n  return document.getElementById(\n    \"element that does not exist\"\n  ) as HTMLCanvasElement;\n}\nfunction DrawingArea() {\n  const myCanvas = useRef<HTMLCanvasElement>(getTempCanvas());\n  const [scene] = useState<Scene>(new Scene());\n  const sceneDrawer = useMemo(() => new SceneDrawer(), []);\n  const mouseEvents = useMemo(() => new MouseEvents(), []);\n  const { drawingMode } = useContext(drawingModeContext);\n  const { currentStep } = useContext(algorithmStepsContext);\n  const {\n    addPoint,\n    addPoints,\n    addSegment,\n    inputPoints,\n    inputSegments,\n  } = useContext(inputDrawingsContext);\n  const [beingDrawenPoint, setBeingDrawenPoint] = useState<Point | null>(null);\n  const [beingDrawenSegment, setBeingDrawenSegment] = useState<Segment | null>(\n    null\n  );\n  const [isDrawingStep, setIsDrawingStep] = useState<boolean>(false);\n  useEffect(() => {\n    setIsDrawingStep(currentStep !== null);\n  }, [currentStep]);\n  useEffect(() => {\n    const renderer = new WebGLRenderer({ canvas: myCanvas.current });\n    renderer.setClearColor(new Color(\"white\"));\n    const camera = new OrthographicCamera(\n      -myCanvas.current.width / 2,\n      myCanvas.current.width / 2,\n      myCanvas.current.height / 2,\n      myCanvas.current.height / -2,\n      0.01,\n      2000\n    );\n    camera.position.z = 50;\n    mouseEvents.canvas = myCanvas.current;\n    const animate = function () {\n      requestAnimationFrame(animate);\n      renderer.render(scene, camera);\n    };\n    animate();\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, []);\n\n  useEffect(() => {\n    sceneDrawer.draw(\n      scene,\n      inputPoints,\n      inputSegments,\n      beingDrawenPoint,\n      beingDrawenSegment,\n      currentStep\n    );\n  }, [\n    inputPoints,\n    inputSegments,\n    beingDrawenPoint,\n    beingDrawenSegment,\n    sceneDrawer,\n    scene,\n    currentStep,\n  ]);\n\n  const onMouseDown = function (e: React.MouseEvent) {\n    if (isDrawingStep) return;\n    const res = mouseEvents.onMouseDown(drawingMode, e);\n    if (res.length !== 3)\n      throw Error(\"onMouseDown must return 3 items, [Point, Segment, Polygon]\");\n    const point = res[0] as Point;\n    const segment = res[1] as Segment;\n    if (point) addPoint(point);\n    if (segment) addSegment(segment);\n  };\n\n  const onMouseMove = function (e: React.MouseEvent) {\n    if (isDrawingStep) return;\n    const res = mouseEvents.onMouseMove(drawingMode, e);\n    if (res.length !== 3)\n      throw Error(\"onMouseMove must return 3 items, [Point, Segment, Polygon]\");\n    const point = res[0] as Point;\n    const segment = res[1] as Segment;\n    if (point) setBeingDrawenPoint(point);\n    if (segment) setBeingDrawenSegment(segment);\n  };\n\n  const onMouseLeave = function () {\n    setBeingDrawenPoint(null);\n    setBeingDrawenSegment(null);\n  };\n\n  const generateRandom = (n: number) => {\n    const points = generateRandomPoints(\n      n,\n      myCanvas.current.height,\n      myCanvas.current.width\n    );\n    addPoints(points);\n  };\n\n  return (\n    <>\n      <canvas\n        onMouseDown={onMouseDown}\n        onMouseMove={onMouseMove}\n        onMouseLeave={onMouseLeave}\n        ref={myCanvas}\n        width=\"500\"\n        height=\"500\"\n        style={{ border: \"1px solid black\" }}\n      ></canvas>\n      {/* <button>Clear</button> */}\n      <div>\n        Generate Random Points:\n        <button onClick={() => generateRandom(10)}>10</button>\n        <button onClick={() => generateRandom(100)}>100</button>\n        <button onClick={() => generateRandom(1000)}>1000</button>\n      </div>\n    </>\n  );\n}\n\nexport default DrawingArea;\n","import React from \"react\";\nimport classes from \"../styles/button.module.scss\";\nimport classNames from \"classnames\";\n\nexport interface ButtonProps {\n  onClick: (value: string) => void;\n  value: string;\n  originalColor: string;\n  clickedColor: string;\n  isClicked: boolean;\n}\n\nfunction Button(props: ButtonProps) {\n  const style = {\n    backgroundColor: props.originalColor,\n  };\n  const myClasses = classNames({\n    [classes.myButton]: true,\n    [classes.clicked]: props.isClicked,\n  });\n\n  if (props.isClicked) {\n    style.backgroundColor = props.clickedColor;\n  }\n  const onClick = function () {\n    if (!props.isClicked) props.onClick(props.value);\n  };\n  return (\n    <button style={style} onClick={onClick} className={myClasses}>\n      {props.value}\n    </button>\n  );\n}\n\nexport default Button;\n","import React, { useCallback, useState, useEffect } from \"react\";\nimport Button, { ButtonProps } from \"./Button\";\n\ninterface Props {\n  buttons: ButtonProps[];\n}\n\nconst ButtonsList = function (props: Props) {\n  const [buttons, setButtons] = useState<ButtonProps[]>([]);\n\n  useEffect(() => {\n    setButtons(props.buttons);\n  }, [props.buttons]);\n\n  const onClick = useCallback(\n    function (value: string): void {\n      //TODO: Change the current drawingContext\n      const button = buttons.find((b: ButtonProps) => b.value === value);\n      if (!button) throw Error(`value ${value} must be found!`);\n\n      if (button.isClicked)\n        throw Error(\n          `this function should not be called if the button is already clicked!`\n        );\n\n      const newButtons = buttons.map((button: ButtonProps) =>\n        button.value === value\n          ? { ...button, isClicked: true }\n          : { ...button, isClicked: false }\n      );\n      setButtons(newButtons);\n    },\n    [buttons]\n  );\n\n  return (\n    <div>\n      {buttons.map((button: ButtonProps) => {\n        const newButton = {\n          ...button,\n          onClick: (value: string) => {\n            onClick(value);\n            button.onClick(value);\n          },\n        };\n        return <Button key={newButton.value} {...newButton}></Button>;\n      })}\n    </div>\n  );\n};\n\nexport { ButtonsList };\n","import React, { useCallback } from \"react\";\nimport { ButtonProps } from \"./Button\";\nimport { ButtonsList } from \"./ButtonsList\";\nimport { drawingModeContext } from \"../contexts/DrawingModeContext\";\n\ninterface Props {\n  buttons: Omit<ButtonProps, \"onClick\">[];\n}\n\nfunction DrawingPalette(props: Props) {\n  const { drawingMode, setCurrentDrawingMode } = React.useContext(\n    drawingModeContext\n  );\n\n  const onClick = useCallback(\n    function (value: string) {\n      setCurrentDrawingMode(value);\n    },\n    [setCurrentDrawingMode]\n  );\n\n  const buttons = props.buttons.map((btn) =>\n    btn.value === drawingMode\n      ? { ...btn, onClick, isClicked: true }\n      : { ...btn, onClick }\n  );\n\n  return (\n    <div className=\"btn-group-vertical\">\n      <ButtonsList buttons={buttons} />\n      <span>{drawingMode}</span>\n    </div>\n  );\n}\n\nexport default DrawingPalette;\n","import React, { useContext } from \"react\";\nimport { algorithmStepsContext } from \"../contexts/AlgorithmStepsContext\";\n\nexport const StatesPlayer = function () {\n  const {\n    stepsCount,\n    currentStepNumber,\n    next,\n    prev,\n    start,\n    isRunning,\n    stop,\n  } = useContext(algorithmStepsContext);\n  const startStopButton = isRunning ? (\n    <button type=\"button\" className=\"btn btn-primary\" onClick={stop}>\n      {\"Stop\"}\n    </button>\n  ) : (\n    <button type=\"button\" className=\"btn btn-primary\" onClick={start}>\n      {\"Start\"}\n    </button>\n  );\n  if (stepsCount === 0) return <></>;\n  return (\n    <>\n      <br></br>\n      <span>\n        {currentStepNumber} / {stepsCount - 1}\n      </span>\n      <div style={{ display: \"flex\", justifyContent: \"center\" }}>\n        {/* <button type=\"button\" className=\"btn btn-primary\">\n          {\"<<\"}\n        </button> */}\n        <button\n          type=\"button\"\n          className=\"btn btn-primary\"\n          onClick={prev}\n          disabled={currentStepNumber === 0}\n        >\n          {\"<\"}\n        </button>\n        {startStopButton}\n        <button\n          type=\"button\"\n          className=\"btn btn-primary\"\n          onClick={next}\n          disabled={currentStepNumber === stepsCount - 1}\n        >\n          {\">\"}\n        </button>\n        {/* <button type=\"button\" className=\"btn btn-primary\">\n          {\">>\"}\n        </button> */}\n      </div>\n      <div className=\"progress\" style={{ marginTop: 20 }}>\n        <div\n          className=\"progress-bar progress-bar-striped progress-bar-animated\"\n          role=\"progressbar\"\n          style={{\n            width: `${(100 * currentStepNumber) / (stepsCount - 1)}%`,\n          }}\n        ></div>\n      </div>\n    </>\n  );\n};\n","import React, { useContext } from \"react\";\nimport { ButtonsList } from \"./ButtonsList\";\nimport IAlgorithm from \"../algorithms/IAlgorithm\";\nimport { algorithmStepsContext } from \"../contexts/AlgorithmStepsContext\";\nimport { inputDrawingsContext } from \"../contexts/InputDrawingsContext\";\ninterface AlgorithmsListPropTypes {\n  algorithms: IAlgorithm[];\n}\n\nconst AlgorithmsList = function (props: AlgorithmsListPropTypes) {\n  const { run } = useContext(algorithmStepsContext);\n  const { inputPoints, inputSegments } = useContext(inputDrawingsContext);\n  const onClick = function (value: string) {\n    const algorithm = props.algorithms.find((algo) => algo.Name() === value);\n    if (!algorithm) throw Error(`Algorithm ${value} must be found`);\n    run(algorithm, inputPoints, inputSegments);\n  };\n  const buttons = props.algorithms.map((algorithm) => ({\n    value: algorithm.Name(),\n    //TODO: Get those from config.\n    clickedColor: \"darkblue\",\n    originalColor: \"lightblue\",\n    isClicked: false,\n    onClick: onClick,\n  }));\n  return (\n    <>\n      <h2>Algorithms</h2>\n      <ButtonsList buttons={buttons} />\n    </>\n  );\n};\n\nexport default AlgorithmsList;\n","import { useCallback, useState } from \"react\";\nimport {\n  DrawingModeContext,\n  DEFAULT_DRAWING_MODE_VALUE,\n} from \"../contexts/DrawingModeContext\";\n\nexport const useDrawingMode = (): DrawingModeContext => {\n  const [drawingMode, setDrawingMode] = useState(\n    DEFAULT_DRAWING_MODE_VALUE.drawingMode\n  );\n\n  const setCurrentDrawingMode = useCallback((newDrawingMode: string): void => {\n    setDrawingMode(newDrawingMode);\n  }, []);\n\n  return {\n    drawingMode,\n    setCurrentDrawingMode,\n  };\n};\n","import Point from \"../dataStructures/Point\";\nimport Segment from \"../dataStructures/Segment\";\n\nexport default class Step {\n  pointsGroups: Point[][];\n  segmentsGroups: Segment[][];\n  constructor() {\n    this.pointsGroups = new Array<Array<Point>>();\n    this.segmentsGroups = new Array<Array<Segment>>();\n  }\n  equals(step: Step): boolean {\n    if (\n      this.pointsGroups.length !== step.pointsGroups.length ||\n      this.segmentsGroups.length !== step.segmentsGroups.length\n    )\n      return false;\n\n    for (let i = 0; i < this.pointsGroups.length; i++) {\n      if (this.pointsGroups[i].length !== step.pointsGroups[i].length)\n        return false;\n\n      for (let j = 0; j < this.pointsGroups[i].length; j++) {\n        const point = this.pointsGroups[i][j];\n        if (!point.equals(step.pointsGroups[i][j])) return false;\n      }\n    }\n\n    for (let i = 0; i < this.segmentsGroups.length; i++) {\n      if (this.segmentsGroups[i].length !== step.segmentsGroups[i].length)\n        return false;\n      for (let j = 0; j < this.segmentsGroups[i].length; j++) {\n        const segment = this.segmentsGroups[i][j];\n        if (!segment.equals(step.segmentsGroups[i][j])) return false;\n      }\n    }\n    return true;\n  }\n  //TODO: Clone()\n}\n","import { useState, useEffect, useCallback } from \"react\";\nimport { AlgorithmStepsContext } from \"../contexts/AlgorithmStepsContext\";\nimport Step from \"../algorithms/step\";\nimport IAlgorithm from \"../algorithms/IAlgorithm\";\nimport Point from \"../dataStructures/Point\";\nimport Segment from \"../dataStructures/Segment\";\n\nexport const useAlgorithmSteps = (): AlgorithmStepsContext => {\n  const [currentIndex, setCurrentIndex] = useState(-1);\n  const [currentStep, setCurrentStep] = useState<Step | null>(null);\n  const [allSteps, setAllSteps] = useState<Step[]>([]);\n  const [isRunning, setIsRunning] = useState<boolean>(false);\n\n  const next = useCallback(() => {\n    if (currentIndex === allSteps.length - 1) return;\n    setCurrentStep(allSteps[currentIndex + 1]);\n    setCurrentIndex(currentIndex + 1);\n  }, [allSteps, currentIndex]);\n\n  useEffect(() => {\n    if (!isRunning) return;\n    setTimeout(() => {\n      next();\n    }, 100);\n    // return () => {\n    //   clearTimeout(to);\n    // };\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [isRunning, currentIndex]);\n\n  const prev = function () {\n    if (currentIndex === 0) return;\n    setCurrentStep(allSteps[currentIndex - 1]);\n    setCurrentIndex(currentIndex - 1);\n  };\n\n  const cleanSteps = function (steps: Step[]): void {\n    for (let index = 1; index < steps.length; index++) {\n      const step = steps[index];\n      if (step.equals(steps[index - 1])) {\n        steps.splice(index, 1);\n        index--;\n      }\n    }\n  };\n\n  const run = function (\n    algorithm: IAlgorithm,\n    inputPoints: Point[],\n    inputSegments: Segment[]\n  ) {\n    const firstStep = new Step();\n    firstStep.pointsGroups = [inputPoints];\n    firstStep.segmentsGroups = [inputSegments];\n    const algorithmSteps = algorithm.Run(inputPoints, inputSegments);\n    const steps = [firstStep, ...algorithmSteps];\n    cleanSteps(steps);\n    setAllSteps(steps);\n    setCurrentStep(steps[0]);\n    setCurrentIndex(0);\n  };\n\n  const stop = function () {\n    setIsRunning(false);\n  };\n\n  const start = function () {\n    setIsRunning(true);\n  };\n\n  return {\n    currentStep,\n    currentStepNumber: currentIndex,\n    stepsCount: allSteps.length,\n    next,\n    prev,\n    run,\n    stop,\n    isRunning,\n    start,\n  };\n};\n","import Step from \"./step\";\nimport Point from \"../dataStructures/Point\";\nimport Segment from \"../dataStructures/Segment\";\nimport IAlgorithm from \"./IAlgorithm\";\n\nexport default class simpleAlgorithm implements IAlgorithm {\n  Run(inputPoints: Point[], inputSegments: Segment[]): Step[] {\n    const steps = inputPoints.map((point) => {\n      const step = new Step();\n      step.pointsGroups.push([point]);\n      return step;\n    });\n    return steps;\n  }\n  Name(): string {\n    return \"Simple\";\n  }\n}\n","import Point from \"./Point\";\n\nexport default class Segment {\n  start: Point;\n  end: Point;\n  id: number;\n  static IDs: number = 0;\n  constructor(start: Point, end: Point) {\n    this.start = start;\n    this.end = end;\n    this.id = Point.IDs++;\n  }\n\n  inverse(): Segment {\n    return new Segment(this.end, this.start);\n  }\n\n  cross(p: Point): number {\n    return (\n      (this.end.x - this.start.x) * (p.y - this.start.y) -\n      (this.end.y - this.start.y) * (p.x - this.start.x)\n    );\n  }\n\n  onLeft(p: Point): boolean {\n    return this.cross(p) < 0;\n  }\n\n  collinear(p: Point): boolean {\n    return this.cross(p) === 0;\n  }\n\n  equals(segment: Segment) {\n    return this.start.equals(segment.start) && this.end.equals(segment.end);\n  }\n}\n","import Point from \"./Point\";\nimport Segment from \"./Segment\";\n\nexport default class Triangle {\n  a: Point;\n  b: Point;\n  c: Point;\n  ab: Segment;\n  bc: Segment;\n  ca: Segment;\n  id: number;\n  static IDs: number = 0;\n\n  constructor(a: Point, b: Point, c: Point) {\n    this.a = a;\n    this.b = b;\n    this.c = c;\n    this.ab = new Segment(a, b);\n    this.bc = new Segment(b, c);\n    this.ca = new Segment(c, a);\n    this.id = Triangle.IDs++;\n  }\n\n  hasPointInside(p: Point): boolean {\n    return this.ab.onLeft(p) && this.bc.onLeft(p) && this.ca.onLeft(p);\n  }\n\n  hasPointOn(p: Point): boolean {\n    return this.ab.collinear(p) || this.bc.collinear(p) || this.ca.collinear(p);\n  }\n}\n","import Step from \"./step\";\nimport Point from \"../dataStructures/Point\";\nimport Segment from \"../dataStructures/Segment\";\nimport IAlgorithm from \"./IAlgorithm\";\nimport { getUniqueElements } from \"../utilities\";\nimport Triangle from \"../dataStructures/Triagnle\";\n\nexport default class extremePointsAlgorithm implements IAlgorithm {\n  unique<T>(...args: T[]): boolean {\n    return new Set(arguments).size === arguments.length;\n  }\n\n  withoutIndices<T>(elements: T[], indices: number[]): T[] {\n    const res: T[] = [];\n    for (let index = 0; index < elements.length; index++) {\n      if (indices.indexOf(index) === -1) {\n        res.push(elements[index]);\n      }\n    }\n    return res;\n  }\n\n  Run(inputPoints: Point[], inputSegments: Segment[]): Step[] {\n    const sortedPoints = inputPoints.sort((a: Point, b: Point): number => {\n      if (a.less(b)) return -1;\n      else if (a.equals(b)) return 0;\n      //a > b\n      else return 1;\n    });\n\n    const uniquePoints = getUniqueElements(sortedPoints);\n\n    if (uniquePoints.length < 3) {\n      if (uniquePoints.length === 2) {\n        const step = new Step();\n        step.segmentsGroups.push([\n          //uniquePoints[0], uniquePoints[1]\n          new Segment(new Point(1, 1), new Point(1, 1)),\n        ]);\n        return [step];\n      }\n    }\n\n    const steps: Step[] = [];\n\n    const deletedPoints: Point[] = [];\n    const deletedIndices: number[] = [];\n\n    for (let i = 0; i < uniquePoints.length; i++) {\n      if (deletedIndices.find((x) => x === i)) continue;\n      for (let j = 0; j < uniquePoints.length; j++) {\n        if (deletedIndices.find((x) => x === j)) continue;\n        for (let k = 0; k < uniquePoints.length; k++) {\n          if (deletedIndices.find((x) => x === k)) continue;\n          const tri = new Triangle(\n            uniquePoints[i],\n            uniquePoints[j],\n            uniquePoints[k]\n          );\n\n          for (let z = 0; z < uniquePoints.length; z++) {\n            if (!this.unique(i, j, k, z)) continue;\n            if (deletedIndices.find((x) => x === z)) continue;\n\n            const p = uniquePoints[z];\n\n            if (!p.equals(tri.a) && !p.equals(tri.b) && !p.equals(tri.c)) {\n              if (tri.hasPointInside(p) || tri.hasPointOn(p)) {\n                const beforeDeleteStep = new Step();\n                beforeDeleteStep.segmentsGroups = [[tri.ab, tri.bc, tri.ca]];\n                beforeDeleteStep.pointsGroups = [\n                  this.withoutIndices(uniquePoints, deletedIndices),\n                  [p],\n                ];\n                    deletedPoints.push(uniquePoints[z]);\n            deletedIndices.push(z);\n\n                const afterDeleteStep = new Step();\n                afterDeleteStep.segmentsGroups = [[tri.ab, tri.bc, tri.ca]];\n                afterDeleteStep.pointsGroups = [\n                  this.withoutIndices(uniquePoints, deletedIndices),\n                ];\n\n                steps.push(beforeDeleteStep);\n                steps.push(afterDeleteStep);\n              }\n            }\n          }\n        }\n      }\n    }\n    const onlyStep = new Step();\n    onlyStep.pointsGroups = [this.withoutIndices(uniquePoints, deletedIndices)];\n\n    return [...steps, onlyStep];\n  }\n  Name(): string {\n    return \"Extreme Points\";\n  }\n}\n","import IAlgorithm from \"./IAlgorithm\";\nimport simpleAlgorithm from \"./simpleAlgorithm\";\nimport extremePointsAlgorithm from \"./extremePoints\";\n\nexport default class AlgorithmsFactory {\n  algorithms: IAlgorithm[];\n  constructor() {\n    this.algorithms = [new simpleAlgorithm(), new extremePointsAlgorithm()];\n  }\n  getAll(): IAlgorithm[] {\n    return this.algorithms;\n  }\n}\n","import {\n  DEFAULT_INPUT_DRAWINGS_CONTEXT_VALUE,\n  InputDrawingsContext,\n} from \"../contexts/InputDrawingsContext\";\nimport { useState, useCallback } from \"react\";\nimport Point from \"../dataStructures/Point\";\nimport Segment from \"../dataStructures/Segment\";\n\nexport const useInputDrawings = (): InputDrawingsContext => {\n  const [inputPoints, setInputPoints] = useState(\n    DEFAULT_INPUT_DRAWINGS_CONTEXT_VALUE.inputPoints\n  );\n\n  const [inputSegments, setInputSegments] = useState(\n    DEFAULT_INPUT_DRAWINGS_CONTEXT_VALUE.inputSegments\n  );\n\n  const addPoint = useCallback(\n    (point: Point): void => {\n      setInputPoints([...inputPoints, point]);\n    },\n    [inputPoints]\n  );\n\n  const addPoints = useCallback(\n    (points: Point[]): void => {\n      setInputPoints([...inputPoints, ...points]);\n    },\n    [inputPoints]\n  );\n\n  const addSegment = useCallback(\n    (segment: Segment): void => {\n      setInputSegments([...inputSegments, segment]);\n    },\n    [inputSegments]\n  );\n\n  const addSegments = useCallback(\n    (segments: Segment[]): void => {\n      setInputSegments([...inputSegments, ...segments]);\n    },\n    [inputSegments]\n  );\n\n  // const clearAll = useCallback(() => {\n  //   setInputPoints(DEFAULT_INPUT_DRAWINGS_CONTEXT_VALUE.inputPoints);\n  //   setInputSegments(DEFAULT_INPUT_DRAWINGS_CONTEXT_VALUE.inputSegments);\n  // }, []);\n\n  return {\n    addPoint,\n    addPoints,\n    addSegment,\n    addSegments,\n    inputPoints,\n    inputSegments,\n  };\n};\n","import React from \"react\";\nimport DrawingArea from \"./DrawingArea\";\nimport DrawingPalette from \"./DrawingPalette\";\nimport \"bootstrap/dist/css/bootstrap.min.css\";\nimport { drawingModeContext } from \"../contexts/DrawingModeContext\";\nimport { algorithmStepsContext } from \"../contexts/AlgorithmStepsContext\";\nimport { inputDrawingsContext } from \"../contexts/InputDrawingsContext\";\nimport { StatesPlayer } from \"./StatesPlayer\";\nimport AlgorithmsList from \"./AlgorithmsList\";\nimport { useDrawingMode } from \"../hooks/drawingMode.hook\";\nimport { useAlgorithmSteps } from \"../hooks/algorithmSteps.hook\";\nimport AlgorithmsFactory from \"../algorithms/algorithmsFactory\";\nimport { useInputDrawings } from \"../hooks/inputDrawings.hook\";\n\n//TODO: Move that to config.\nconst drawingButtons = (function () {\n  const ret = [\n    {\n      isClicked: false,\n      value: \"Nothing\",\n      originalColor: \"lightgrey\",\n      clickedColor: \"grey\",\n    },\n    {\n      isClicked: false,\n      value: \"Point\",\n      originalColor: \"#fe2636\",\n      clickedColor: \"darkred\",\n    },\n    {\n      isClicked: false,\n      value: \"Line\",\n      originalColor: \"#f5dd33\",\n      clickedColor: \"#f9a905\",\n    },\n    {\n      isClicked: false,\n      value: \"Polygon\",\n      originalColor: \"#90eb35\",\n      clickedColor: \"green\",\n    },\n  ];\n  return ret;\n})();\n\nfunction App() {\n  const algorithmFactory = new AlgorithmsFactory();\n  return (\n    <inputDrawingsContext.Provider value={useInputDrawings()}>\n      <algorithmStepsContext.Provider value={useAlgorithmSteps()}>\n        <drawingModeContext.Provider value={useDrawingMode()}>\n          <div className=\"container\">\n            <div className=\"row\">\n              <div className=\"col-sm-3\">\n                <AlgorithmsList algorithms={algorithmFactory.getAll()} />\n              </div>\n              <div className=\"col-sm-6\">\n                <DrawingArea />\n                <StatesPlayer />\n              </div>\n              <div className=\"col-sm-3\">\n                <DrawingPalette buttons={drawingButtons} />\n              </div>\n            </div>\n          </div>\n        </drawingModeContext.Provider>\n      </algorithmStepsContext.Provider>\n    </inputDrawingsContext.Provider>\n  );\n}\n\nexport default App;\n","import React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport App from \"./components/App\";\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById(\"root\")\n);\n"],"sourceRoot":""}